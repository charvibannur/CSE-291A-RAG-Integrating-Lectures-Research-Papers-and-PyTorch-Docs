Distributed communication package -
torch.distributed
Created On: Jul 12, 2017 | Last Updated On: Jul 14, 2025
Please refer to PyTorch Distributed Overview for a brief introduction to all features related
to distributed training.
Backends
torch.distributed  supports three built-in backends, each with different capabilities. The table
below shows which functions are available for use with CPU / CUDA tensors. MPI supports CUDA
only if the implementation used to build PyTorch supports it.
Backend gloo mpi nccl
Device CPUGPUCPUGPUCPUGPU
send ✓ ✘✓? ✘✓
recv ✓ ✘✓? ✘✓
broadcast ✓✓✓? ✘✓
all_reduce ✓✓✓? ✘✓
reduce ✓✓✓? ✘✓
all_gather ✓✓✓? ✘✓
gather ✓✓✓? ✘✓Note 
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 1/83Backend gloo mpi nccl
Device CPUGPUCPUGPUCPUGPU
scatter ✓✓✓? ✘✓
reduce_scatter ✓✓ ✘ ✘ ✘✓
all_to_all ✓✓✓? ✘✓
barrier ✓ ✘✓? ✘✓
Backends that come with PyTorch
PyTorch distributed package supports Linux (stable), MacOS (stable), and Windows (prototype). By
default for Linux, the Gloo and NCCL backends are built and included in PyTorch distributed (NCCL
only when building with CUDA). MPI is an optional backend that can only be included if you build
PyTorch from source. (e.g. building PyTorch on a host that has MPI installed.)
As of PyTorch v1.8, Windows supports all collective communications backend but NCCL, If
the init_method  argument of init_process_group()  points to a file it must adhere to
the following schema:
Local file system, init_method="file:///d:/tmp/some_file"
Shared file system,
init_method="file://////{machine_name}/{share_folder_name}/some_file"
Same as on Linux platform, you can enable TcpStore by setting environment variables,
MASTER_ADDR and MASTER_PORT.
Which backend to use?
In the past, we were often asked: “which backend should I use?”.
Rule of thumbNote 
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 2/83Use the NCCL backend for distributed GPU training
Use the Gloo backend for distributed CPU training.
GPU hosts with InfiniBand interconnect
Use NCCL, since itʼs the only backend that currently supports InfiniBand and GPUDirect.
GPU hosts with Ethernet interconnect
Use NCCL, since it currently provides the best distributed GPU training performance,
especially for multiprocess single-node or multi-node distributed training. If you encounte
any problem with NCCL, use Gloo as the fallback option. (Note that Gloo currently runs
slower than NCCL for GPUs.)
CPU hosts with InfiniBand interconnect
If your InfiniBand has enabled IP over IB, use Gloo, otherwise, use MPI instead. We are
planning on adding InfiniBand support for Gloo in the upcoming releases.
CPU hosts with Ethernet interconnect
Use Gloo, unless you have specific reasons to use MPI.
Common environment variables
Choosing the network interface to use
By default, both the NCCL and Gloo backends will try to find the right network interface to use. If
the automatically detected interface is not correct, you can override it using the following
environment variables (applicable to the respective backend):
NCCL_SOCKET_IFNAME, for example export NCCL_SOCKET_IFNAME=eth0
GLOO_SOCKET_IFNAME, for example export GLOO_SOCKET_IFNAME=eth0
If youʼre using the Gloo backend, you can specify multiple interfaces by separating them by a
comma, like this: export GLOO_SOCKET_IFNAME=eth0,eth1,eth2,eth3 . The backend will dispatch
operations in a round-robin fashion across these interfaces. It is imperative that all processes
specify the same number of interfaces in this variable.
Other NCCL environment variablesTo analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 3/83Debugging - in case of NCCL failure, you can set NCCL_DEBUG=INFO  to print an explicit warning
message as well as basic NCCL initialization information.
You may also use NCCL_DEBUG_SUBSYS  to get more details about a specific aspect of NCCL. For
example, NCCL_DEBUG_SUBSYS=COLL  would print logs of collective calls, which may be helpful when
debugging hangs, especially those caused by collective type or message size mismatch. In case of
topology detection failure, it would be helpful to set NCCL_DEBUG_SUBSYS=GRAPH  to inspect the
detailed detection result and save as reference if further help from NCCL team is needed.
Performance tuning - NCCL performs automatic tuning based on its topology detection to save
usersʼ tuning effort. On some socket-based systems, users may still try tuning
NCCL_SOCKET_NTHREADS  and NCCL_NSOCKS_PERTHREAD  to increase socket network bandwidth.
These two environment variables have been pre-tuned by NCCL for some cloud providers, such as
AWS or GCP.
For a full list of NCCL environment variables, please refer to NVIDIA NCCLʼs official documentation
You can tune NCCL communicators even further using
torch.distributed.ProcessGroupNCCL.NCCLConfig  and
torch.distributed.ProcessGroupNCCL.Options . Learn more about them using help (e.g.
help(torch.distributed.ProcessGroupNCCL.NCCLConfig) ) in the interpreter.
Basics
The torch.distributed  package provides PyTorch support and communication primitives for
multiprocess parallelism across several computation nodes running on one or more machines. The
class torch.nn.parallel.DistributedDataParallel()  builds on this functionality to provide
synchronous distributed training as a wrapper around any PyTorch model. This differs from the
kinds of parallelism provided by Multiprocessing package - torch.multiprocessing and
torch.nn.DataParallel()  in that it supports multiple network-connected machines and in that
the user must explicitly launch a separate copy of the main training script for each process.
In the single-machine synchronous case, torch.distributed  or the
torch.nn.parallel.DistributedDataParallel()  wrapper may still have advantages over other
approaches to data-parallelism, including torch.nn.DataParallel() :
Each process maintains its own optimizer and performs a complete optimization step with eac
iteration. While this may appear redundant, since the gradients have already been gatheredTo analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 4/83[source
[sourcetogether and averaged across processes and are thus the same for every process, this means
that no parameter broadcast step is needed, reducing time spent transferring tensors between
nodes.
Each process contains an independent Python interpreter, eliminating the extra interpreter
overhead and “GIL-thrashing” that comes from driving several execution threads, model
replicas, or GPUs from a single Python process. This is especially important for models that
make heavy use of the Python runtime, including models with recurrent layers or many small
components.
Initialization
The package needs to be initialized using the torch.distributed.init_process_group()  or
torch.distributed.device_mesh.init_device_mesh()  function before calling any other
methods. Both block until all processes have joined.
Initialization is not thread-safe. Process group creation should be performed from a single
thread, to prevent inconsistent ‘UUIDʼ assignment across ranks, and to prevent races
during initialization that can lead to hangs.
torch.distributed. is_available ( )
Return True if the distributed package is available.
Otherwise, torch.distributed  does not expose any other APIs. Currently,
torch.distributed  is available on Linux, MacOS and Windows. Set USE_DISTRIBUTED=1  to
enable it when building PyTorch from source. Currently, the default value is
USE_DISTRIBUTED=1  for Linux and Windows, USE_DISTRIBUTED=0  for MacOS.
Return type:
bool
torch.distributed. init_process_group (backend=None, init_method =None,
timeout=None, world_size =-1, rank=-1, store=None, group_name ='',
pg_options =None, device_id =None )Warning ⚠
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 5/83Initialize the default distributed process group.
This will also initialize the distributed package.
There are 2 main ways to initialize a process group:
1. Specify store, rank, and world_size  explicitly.
2. Specify init_method  (a URL string) which indicates where/how to discover peers.
Optionally specify rank and world_size, or encode all required parameters in the
URL and omit them.
If neither is specified, init_method  is assumed to be “env://”.
Parameters:
backend (str or Backend, optional) – The backend to use. Depending on build-time
configurations, valid values include mpi, gloo, nccl, ucc, or one that is registered
by a third-party plugin. Since 2.6, if backend is not provided, c10d will use a backend
registered for the device type indicated by the device_id kwarg (if provided). The know
default registrations today are: nccl for cuda, gloo for cpu. If neither backend no
device_id  is provided, c10d will detect the accelerator on the run-time machine and
use a backend registered for that detected accelerator (or cpu). This field can be give
as a lowercase string (e.g., "gloo"), which can also be accessed via Backend
attributes (e.g., Backend.GLOO). If using multiple processes per machine with nccl
backend, each process must have exclusive access to every GPU it uses, as sharing
GPUs between processes can result in deadlock or NCCL invalid usage. ucc backend
is experimental. Default backend for the device can be queried with
get_default_backend_for_device() .
init_method (str, optional) – URL specifying how to initialize the process group. Defau
is “env://” if no init_method  or store is specified. Mutually exclusive with store.
world_size (int, optional) – Number of processes participating in the job. Required if
store is specified.
rank (int, optional) – Rank of the current process (it should be a number between 0 an
world_size-1). Required if store is specified.
store (Store, optional) – Key/value store accessible to all workers, used to exchange
connection/address information. Mutually exclusive with init_method.
timeout (timedelta, optional) – Timeout for operations executed against the process
group. Default value is 10 minutes for NCCL and 30 minutes for other backends. This is
the duration after which collectives will be aborted asynchronously and the process wiTo analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 6/83crash. This is done since CUDA execution is async and it is no longer safe to continue
executing user code since failed async NCCL operations might result in subsequent
CUDA operations running on corrupted data. When TORCH_NCCL_BLOCKING_WAIT is
set, the process will block and wait for this timeout.
group_name (str, optional, deprecated) – Group name. This argument is ignored
pg_options (ProcessGroupOptions, optional) – process group options specifying wha
additional options need to be passed in during the construction of specific process
groups. As of now, the only options we support is ProcessGroupNCCL.Options  for the
nccl backend, is_high_priority_stream  can be specified so that the nccl backend
can pick up high priority cuda streams when thereʼre compute kernels waiting. For othe
available options to config nccl, See https://docs.nvidia.com/deeplearning/nccl/user-
guide/docs/api/types.html#ncclconfig-t
device_id (torch.device | int, optional) – a single, specific device this process will work
on, allowing for backend-specific optimizations. Currently this has two effects, only
under NCCL: the communicator is immediately formed (calling ncclCommInit*
immediately rather than the normal lazy call) and sub-groups will use ncclCommSplit
when possible to avoid unnecessary overhead of group creation. If you want to know
NCCL initialization error early, you can also use this field. If an int is provided, the API
assumes that the accelerator type at compile time will be used.
To enable backend == Backend.MPI, PyTorch needs to be built from source on a
system that supports MPI.
Support for multiple backends is experimental. Currently when no backend is
specified, both gloo and nccl backends will be created. The gloo backend will be
used for collectives with CPU tensors and the nccl backend will be used for
collectives with CUDA tensors. A custom backend can be specified by passing in a
string with format “<device_type>:<backend_name>,<device_type>:
<backend_name>”, e.g. “cpu:gloo,cuda:custom_backend”.Note 
Note 
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 7/83[sourcetorch.distributed.device_mesh. init_device_mesh (device_type , mesh_shape ,
*, mesh_dim_names =None )
Initializes a DeviceMesh based on device_type, mesh_shape, and mesh_dim_names parameter
This creates a DeviceMesh with an n-dimensional array layout, where n is the length of
mesh_shape. If mesh_dim_names is provided, each dimension is labeled as mesh_dim_names[i
init_device_mesh follows SPMD programming model, meaning the same PyTorch
Python program runs on all processes/ranks in the cluster. Ensure mesh_shape (the
dimensions of the nD array describing device layout) is identical across all ranks.
Inconsistent mesh_shape may lead to hanging.
If no process group is found, init_device_mesh will initialize distributed process
group/groups required for distributed communications behind the scene.
Parameters:
device_type (str) – The device type of the mesh. Currently supports: “cpu”,
“cuda/cuda-like”. Passing in a device type with a GPU index, such as “cuda:0”, is not
allowed.
mesh_shape (Tuple[int]) – A tuple defining the dimensions of the multi-dimensional
array describing the layout of devices.
mesh_dim_names (Tuple[str], optional) – A tuple of mesh dimension names to assign
to each dimension of the multi-dimensional array describing the layout of devices. Its
length must match the length of mesh_shape. Each string in mesh_dim_names must be
unique.
Returns:
A DeviceMesh  object representing the device layout.
Return type:
DeviceMesh
Example:Note 
Note 
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 8/83[source
[source
[source
[source
[sourcetorch.distributed. is_initialized ( )
Check if the default process group has been initialized.
Return type:
bool
torch.distributed. is_mpi_available ( )
Check if the MPI backend is available.
Return type:
bool
torch.distributed. is_nccl_available ( )
Check if the NCCL backend is available.
Return type:
bool
torch.distributed. is_gloo_available ( )
Check if the Gloo backend is available.
Return type:
bool
torch.distributed.distributed_c10d. is_xccl_available ( )
Check if the XCCL backend is available.>>> from torch.distributed.device_mesh  import init_device_mesh
>>>
>>> mesh_1d = init_device_mesh ("cuda", mesh_shape =(8,))
>>> mesh_2d = init_device_mesh ("cuda", mesh_shape =(2, 8), mesh_dim_names =("dp",
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 9/83[source
[sourceReturn type:
bool
torch.distributed. is_torchelastic_launched ( )
Check whether this process was launched with torch.distributed.elastic  (aka
torchelastic).
The existence of TORCHELASTIC_RUN_ID  environment variable is used as a proxy to determine
whether the current process was launched with torchelastic. This is a reasonable proxy since
TORCHELASTIC_RUN_ID  maps to the rendezvous id which is always a non-null value indicating
the job id for peer discovery purposes..
Return type:
bool
torch.distributed. get_default_backend_for_device (device )
Return the default backend for the given device.
Parameters:
device (Union[str, torch.device]) – The device to get the default backend for.
Returns:
The default backend for the given device as a lower case string.
Return type:
str
Currently three initialization methods are supported:
TCP initialization
There are two ways to initialize using TCP, both requiring a network address reachable from all
processes and a desired world_size. The first way requires specifying an address that belongs to
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 10/83the rank 0 process. This initialization method requires that all processes have manually specified
ranks.
Note that multicast address is not supported anymore in the latest distributed package.
group_name  is deprecated as well.
Shared file-system initialization
Another initialization method makes use of a file system that is shared and visible from all machines
in a group, along with a desired world_size. The URL should start with file:// and contain a
path to a non-existent file (in an existing directory) on a shared file system. File-system initialization
will automatically create that file if it doesnʼt exist, but will not delete the file. Therefore, it is your
responsibility to make sure that the file is cleaned up before the next init_process_group()  call
on the same file path/name.
Note that automatic rank assignment is not supported anymore in the latest distributed package
and group_name  is deprecated as well.
This method assumes that the file system supports locking using fcntl - most local
systems and NFS support it.import torch.distributed  as dist
# Use address of one of the machines
dist.init_process_group (backend, init_method ='tcp://10.1.1.20:23456' ,
                        rank=args.rank, world_size =4)
Warning ⚠
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 11/83This method will always create the file and try its best to clean up and remove the file at
the end of the program. In other words, each initialization with the file init method will need
a brand new empty file in order for the initialization to succeed. If the same file used by the
previous initialization (which happens not to get cleaned up) is used again, this is
unexpected behavior and can often cause deadlocks and failures. Therefore, even though
this method will try its best to clean up the file, if the auto-delete happens to be
unsuccessful, it is your responsibility to ensure that the file is removed at the end of the
training to prevent the same file to be reused again during the next time. This is especially
important if you plan to call init_process_group()  multiple times on the same file name.
In other words, if the file is not removed/cleaned up and you call init_process_group()
again on that file, failures are expected. The rule of thumb here is that, make sure that the
file is non-existent or empty every time init_process_group()  is called.
Environment variable initialization
This method will read the configuration from environment variables, allowing one to fully customize
how the information is obtained. The variables to be set are:
MASTER_PORT  - required; has to be a free port on machine with rank 0
MASTER_ADDR  - required (except for rank 0); address of rank 0 node
WORLD_SIZE  - required; can be set either here, or in a call to init function
RANK - required; can be set either here, or in a call to init function
The machine with rank 0 will be used to set up all connections.
This is the default method, meaning that init_method  does not have to be specified (or can be
env://).import torch.distributed  as dist
# rank should always be specified
dist.init_process_group (backend, init_method ='file:///mnt/nfs/sharedfile' ,
                        world_size =4, rank=args.rank)Warning ⚠
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 12/83[source
[sourceImproving initialization time
TORCH_GLOO_LAZY_INIT  - establishes connections on demand rather than using a full mesh
which can greatly improve initialization time for non all2all operations.
Post-Initialization
Once torch.distributed.init_process_group()  was run, the following functions can be used.
To check whether the process group has already been initialized use
torch.distributed.is_initialized() .
class torch.distributed. Backend (name )
An enum-like class for backends.
Available backends: GLOO, NCCL, UCC, MPI, XCCL, and other registered backends.
The values of this class are lowercase strings, e.g., "gloo". They can be accessed as
attributes, e.g., Backend.NCCL.
This class can be directly called to parse the string, e.g., Backend(backend_str)  will check if
backend_str  is valid, and return the parsed lowercase string if so. It also accepts uppercase
strings, e.g., Backend("GLOO")  returns "gloo".
The entry Backend.UNDEFINED  is present but only used as initial value of some fields.
Users should neither use it directly nor assume its existence.
classmethod  register_backend (name, func, extended_api =False,
devices=None )
Register a new backend with the given name and instantiating function.
This class method is used by 3rd party ProcessGroup  extension to register new backend
Parameters:Note 
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 13/83[source
[sourcename (str) – Backend name of the ProcessGroup  extension. It should match the
one in init_process_group() .
func (function) – Function handler that instantiates the backend. The function
should be implemented in the backend extension and takes four arguments,
including store, rank, world_size, and timeout.
extended_api (bool, optional) – Whether the backend supports extended
argument structure. Default: False. If set to True, the backend will get an
instance of c10d::DistributedBackendOptions , and a process group options
object as defined by the backend implementation.
device (str or list of str, optional) – device type this backend supports, e.g. “cpu”,
“cuda”, etc. If None, assuming both “cpu” and “cuda”
This support of 3rd party backend is experimental and subject to change.
torch.distributed. get_backend (group=None )
Return the backend of the given process group.
Parameters:
group (ProcessGroup, optional) – The process group to work on. The default is the
general main process group. If another specific group is specified, the calling process
must be part of group.
Returns:
The backend of the given process group as a lower case string.
Return type:
Backend
torch.distributed. get_rank (group=None )
Return the rank of the current process in the provided group, default otherwise.
Rank is a unique identifier assigned to each process within a distributed process group. They
are always consecutive integers ranging from 0 to world_size.Note 
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 14/83[sourceParameters:
group (ProcessGroup, optional) – The process group to work on. If None, the default
process group will be used.
Returns:
The rank of the process group -1, if not part of the group
Return type:
int
torch.distributed. get_world_size (group=None )
Return the number of processes in the current process group.
Parameters:
group (ProcessGroup, optional) – The process group to work on. If None, the default
process group will be used.
Returns:
The world size of the process group -1, if not part of the group
Return type:
int
Shutdown
It is important to clean up resources on exit by calling destroy_process_group() .
The simplest pattern to follow is to destroy every process group and backend by calling
destroy_process_group()  with the default value of None for the group argument, at a point in
the training script where communications are no longer needed, usually near the end of main(). The
call should be made once per trainer-process, not at the outer process-launcher level.
if destroy_process_group()  is not called by all ranks in a pg within the timeout duration,
especially when there are multiple process-groups in the application e.g. for N-D parallelism, hangs
on exit are possible. This is because the destructor for ProcessGroupNCCL calls ncclCommAbort,
which must be called collectively, but the order of calling ProcessGroupNCCLʼs destructor if called
by pythonʼs GC is not deterministic. Calling destroy_process_group()  helps by ensuring
ncclCommAbort is called in a consistent order across ranks, and avoids calling ncclCommAbort
during ProcessGroupNCCLʼs destructor.To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 15/83[sourceReinitialization
destroy_process_group  can also be used to destroy individual process groups. One use case
could be fault tolerant training, where a process group may be destroyed and then a new one
initialized during runtime. In this case, itʼs critical to synchronize the trainer processes using some
means other than torch.distributed primitives _after_ calling destroy and before subsequently
initializing. This behavior is currently unsupported/untested, due to the difficulty of achieving this
synchronization, and is considered a known issue. Please file a github issue or RFC if this is a use
case thatʼs blocking you.
Groups
By default collectives operate on the default group (also called the world) and require all processes
to enter the distributed function call. However, some workloads can benefit from more fine-grained
communication. This is where distributed groups come into play. new_group()  function can be
used to create new groups, with arbitrary subsets of all processes. It returns an opaque group
handle that can be given as a group argument to all collectives (collectives are distributed
functions to exchange information in certain well-known programming patterns).
torch.distributed. new_group (ranks=None, timeout=None, backend=None,
pg_options =None, use_local_synchronization =False, group_desc =None,
device_id =None )
Create a new distributed group.
This function requires that all processes in the main group (i.e. all processes that are part of th
distributed job) enter this function, even if they are not going to be members of the group.
Additionally, groups should be created in the same order in all processes.
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 16/83Safe concurrent usage: When using multiple process groups with the NCCL backend,
the user must ensure a globally consistent execution order of collectives across ranks.
If multiple threads within a process issue collectives, explicit synchronization is
necessary to ensure consistent ordering.
When using async variants of torch.distributed communication APIs, a work object is
returned and the communication kernel is enqueued on a separate CUDA stream,
allowing overlap of communication and computation. Once one or more async ops
have been issued on one process group, they must be synchronized with other cuda
streams by calling work.wait() before using another process group.
See Using multiple NCCL communicators concurrently
<https://docs.nvidia.com/deeplearning/nccl/user-
guide/docs/usage/communicators.html#using-multiple-nccl-communicators-
concurrently> for more details.
Parameters:
ranks (list[int]) – List of ranks of group members. If None, will be set to all ranks.
Default is None.
timeout (timedelta, optional) – see init_process_group for details and default value.
backend (str or Backend, optional) – The backend to use. Depending on build-time
configurations, valid values are gloo and nccl. By default uses the same backend as
the global group. This field should be given as a lowercase string (e.g., "gloo"), which
can also be accessed via Backend attributes (e.g., Backend.GLOO). If None is passed
in, the backend corresponding to the default process group will be used. Default is
None.
pg_options (ProcessGroupOptions, optional) – process group options specifying wha
additional options need to be passed in during the construction of specific process
groups. i.e. for the nccl backend, is_high_priority_stream  can be specified so tha
process group can pick up high priority cuda streams. For other available options to
config nccl, See https://docs.nvidia.com/deeplearning/nccl/user-
guide/docs/api/types.html#ncclconfig-tuse_local_synchronization (bool, optional):
perform a group-local barrier at the end of the process group creation. This is different
in that non-member ranks donʼt need to call into API and donʼt join the barrier.Warning ⚠
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 17/83[source
[sourcegroup_desc (str, optional) – a string to describe the process group.
device_id (torch.device, optional) – a single, specific device to “bind” this process to,
The new_group call will try to initialize a communication backend immediately for the
device if this field is given.
Returns:
A handle of distributed group that can be given to collective calls or
GroupMember.NON_GROUP_MEMBER if the rank is not part of ranks.
N.B. use_local_synchronization doesnʼt work with MPI.
N.B. While use_local_synchronization=True can be significantly faster with larger clusters and
small process groups, care must be taken since it changes cluster behavior as non-member
ranks donʼt join the group barrier().
N.B. use_local_synchronization=True can lead to deadlocks when each rank creates multiple
overlapping process groups. To avoid that, make sure all ranks follow the same global creation
order.
torch.distributed. get_group_rank (group, global_rank )
Translate a global rank into a group rank.
global_rank  must be part of group otherwise this raises RuntimeError.
Parameters:
group (ProcessGroup) – ProcessGroup to find the relative rank.
global_rank (int) – Global rank to query.
Returns:
Group rank of global_rank  relative to group
Return type:
int
N.B. calling this function on the default process group returns identity
torch.distributed. get_global_rank (group, group_rank )
Translate a group rank into a global rank.To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 18/83[source
[sourcegroup_rank  must be part of group otherwise this raises RuntimeError.
Parameters:
group (ProcessGroup) – ProcessGroup to find the global rank from.
group_rank (int) – Group rank to query.
Returns:
Global rank of group_rank  relative to group
Return type:
int
N.B. calling this function on the default process group returns identity
torch.distributed. get_process_group_ranks (group )
Get all ranks associated with group.
Parameters:
group (Optional[ProcessGroup]) – ProcessGroup to get all ranks from. If None, the
default process group will be used.
Returns:
List of global ranks ordered by group rank.
Return type:
list[int]
DeviceMesh
DeviceMesh is a higher level abstraction that manages process groups (or NCCL communicators). 
allows user to easily create inter node and intra node process groups without worrying about how t
set up the ranks correctly for different sub process groups, and it helps manage those distributed
process group easily. init_device_mesh()  function can be used to create new DeviceMesh, with 
mesh shape describing the device topology.
class torch.distributed.device_mesh. DeviceMesh (device_type , mesh, *,
mesh_dim_names =None, _init_backend =True )To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 19/83DeviceMesh represents a mesh of devices, where layout of devices could be represented as a
n-d dimension array, and each value of the n-d dimensional array is the global id of the default
process group ranks.
DeviceMesh could be used to setup the N dimensional device connections across the cluster,
and manage the ProcessGroups for N dimensional parallelisms. Communications could happen
on each dimension of the DeviceMesh separately. DeviceMesh respects the device that user
selects already (i.e. if user call torch.cuda.set_device before the DeviceMesh initialization), and
will select/set the device for the current process if user does not set the device beforehand.
Note that manual device selection should happen BEFORE the DeviceMesh initialization.
DeviceMesh can also be used as a context manager when using together with DTensor APIs.
DeviceMesh follows SPMD programming model, which means the same PyTorch
Python program is running on all processes/ranks in the cluster. Therefore, users need
to make sure the mesh array (which describes the layout of devices) should be
identical across all ranks. Inconsistent mesh will lead to silent hang.
Parameters:
device_type (str) – The device type of the mesh. Currently supports: “cpu”,
“cuda/cuda-like”.
mesh (ndarray) – A multi-dimensional array or an integer tensor describing the layout
of devices, where the IDs are global IDs of the default process group.
Returns:
A DeviceMesh  object representing the device layout.
Return type:
DeviceMesh
The following program runs on each process/rank in an SPMD manner. In this example, we hav
2 hosts with 4 GPUs each. A reduction over the first dimension of mesh will reduce across
columns (0, 4), .. and (3, 7), a reduction over the second dimension of mesh reduces across
rows (0, 1, 2, 3) and (4, 5, 6, 7).
Example:Note 
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 20/83[sourcestatic from_group (group, device_type , mesh=None, *,
mesh_dim_names =None )
Constructs a DeviceMesh  with device_type  from an existing ProcessGroup  or a list of
existing ProcessGroup.
The constructed device mesh has number of dimensions equal to the number of groups
passed. For example, if a single process group is passed in, the resulted DeviceMesh is a
1D mesh. If a list of 2 process groups is passed in, the resulted DeviceMesh is a 2D mesh.
If more than one group is passed, then the mesh and mesh_dim_names  arguments are
required. The order of the process groups passed in determines the topology of the mesh
For example, the first process group will be the 0th dimension of the DeviceMesh. The
mesh tensor passed in must have the same number of dimensions as the number of
process groups passed in, and the order of the dimensions in the mesh tensor must match
the order in the process groups passed in.
Parameters:
group (ProcessGroup or list[ProcessGroup]) – the existing ProcessGroup or a list
of existing ProcessGroups.
device_type (str) – The device type of the mesh. Currently supports: “cpu”,
“cuda/cuda-like”. Passing in a device type with a GPU index, such as “cuda:0”, is no
allowed.
mesh (torch.Tensor or ArrayLike, optional) – A multi-dimensional array or an
integer tensor describing the layout of devices, where the IDs are global IDs of the
default process group. Default is None.
mesh_dim_names (tuple[str], optional) – A tuple of mesh dimension names to
assign to each dimension of the multi-dimensional array describing the layout of
devices. Its length must match the length of mesh_shape. Each string in
mesh_dim_names must be unique. Default is None.
Returns:
A DeviceMesh  object representing the device layout.>>> from torch.distributed.device_mesh  import DeviceMesh
>>>
>>> # Initialize device mesh as (2, 4) to represent the topology
>>> # of cross-host(dim 0), and within-host (dim 1).
>>> mesh = DeviceMesh (device_type ="cuda", mesh=[[0, 1, 2, 3],[4, 5, 6, 7]])
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 21/83[source
[source
[source
[sourceReturn type:
DeviceMesh
get_all_groups ( )
Returns a list of ProcessGroups for all mesh dimensions.
Returns:
A list of ProcessGroup  object.
Return type:
list[torch.distributed.distributed_c10d.ProcessGroup]
get_coordinate ( )
Return the relative indices of this rank relative to all dimensions of the mesh. If this rank is
not part of the mesh, return None.
Return type:
Optional[list[int]]
get_group (mesh_dim =None )
Returns the single ProcessGroup specified by mesh_dim, or, if mesh_dim is not specified
and the DeviceMesh is 1-dimensional, returns the only ProcessGroup in the mesh.
Parameters:
mesh_dim (str/python:int, optional) – it can be the name of the mesh dimension o
the index
None. (of the mesh dimension. Default is) –
Returns:
A ProcessGroup  object.
Return type:
ProcessGroup
get_local_rank (mesh_dim =None )To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 22/83[sourceReturns the local rank of the given mesh_dim of the DeviceMesh.
Parameters:
mesh_dim (str/python:int, optional) – it can be the name of the mesh dimension o
the index
None. (of the mesh dimension. Default is) –
Returns:
An integer denotes the local rank.
Return type:
int
The following program runs on each process/rank in an SPMD manner. In this example, we
have 2 hosts with 4 GPUs each. Calling mesh_2d.get_local_rank(mesh_dim=0) on rank 0,
1, 2, 3 would return 0. Calling mesh_2d.get_local_rank(mesh_dim=0) on rank 4, 5, 6, 7
would return 1. Calling mesh_2d.get_local_rank(mesh_dim=1) on rank 0, 4 would return 0.
Calling mesh_2d.get_local_rank(mesh_dim=1) on rank 1, 5 would return 1. Calling
mesh_2d.get_local_rank(mesh_dim=1) on rank 2, 6 would return 2. Calling
mesh_2d.get_local_rank(mesh_dim=1) on rank 3, 7 would return 3.
Example:
get_rank ( )
Returns the current global rank.
Return type:
int
Point-to-point communication>>> from torch.distributed.device_mesh  import DeviceMesh
>>>
>>> # Initialize device mesh as (2, 4) to represent the topology
>>> # of cross-host(dim 0), and within-host (dim 1).
>>> mesh = DeviceMesh (device_type ="cuda", mesh=[[0, 1, 2, 3],[4, 5, 6, 7]])
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 23/83[source
[sourcetorch.distributed. send (tensor, dst=None, group=None, tag=0,
group_dst =None )
Send a tensor synchronously.
tag is not supported with the NCCL backend.
Parameters:
tensor (Tensor) – Tensor to send.
dst (int) – Destination rank on global process group (regardless of group argument).
Destination rank should not be the same as the rank of the current process.
group (ProcessGroup, optional) – The process group to work on. If None, the default
process group will be used.
tag (int, optional) – Tag to match send with remote recv
group_dst (int, optional) – Destination rank on group. Invalid to specify both dst an
group_dst.
torch.distributed. recv (tensor, src=None, group=None, tag=0,
group_src =None )
Receives a tensor synchronously.
tag is not supported with the NCCL backend.
Parameters:
tensor (Tensor) – Tensor to fill with received data.
src (int, optional) – Source rank on global process group (regardless of group
argument). Will receive from any process if unspecified.
group (ProcessGroup, optional) – The process group to work on. If None, the default
process group will be used.
tag (int, optional) – Tag to match recv with remote sendWarning ⚠
Warning ⚠
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 24/83[sourcegroup_src (int, optional) – Destination rank on group. Invalid to specify both src an
group_src.
Returns:
Sender rank -1, if not part of the group
Return type:
int
isend() and irecv() return distributed request objects when used. In general, the type of this
object is unspecified as they should never be created manually, but they are guaranteed to support
two methods:
is_completed()  - returns True if the operation has finished
wait() - will block the process until the operation is finished. is_completed()  is guaranteed
to return True once it returns.
torch.distributed. isend (tensor, dst=None, group=None, tag=0,
group_dst =None )
Send a tensor asynchronously.
Modifying tensor before the request completes causes undefined behavior.
tag is not supported with the NCCL backend.
Unlike send, which is blocking, isend allows src == dst rank, i.e. send to self.
Parameters:
tensor (Tensor) – Tensor to send.
dst (int) – Destination rank on global process group (regardless of group argument)
group (ProcessGroup, optional) – The process group to work on. If None, the default
process group will be used.
tag (int, optional) – Tag to match send with remote recvWarning ⚠
Warning ⚠
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 25/83[source
[sourcegroup_dst (int, optional) – Destination rank on group. Invalid to specify both dst an
group_dst
Returns:
A distributed request object. None, if not part of the group
Return type:
Optional[Work]
torch.distributed. irecv (tensor, src=None, group=None, tag=0,
group_src =None )
Receives a tensor asynchronously.
tag is not supported with the NCCL backend.
Unlike recv, which is blocking, irecv allows src == dst rank, i.e. recv from self.
Parameters:
tensor (Tensor) – Tensor to fill with received data.
src (int, optional) – Source rank on global process group (regardless of group
argument). Will receive from any process if unspecified.
group (ProcessGroup, optional) – The process group to work on. If None, the default
process group will be used.
tag (int, optional) – Tag to match recv with remote send
group_src (int, optional) – Destination rank on group. Invalid to specify both src an
group_src.
Returns:
A distributed request object. None, if not part of the group
Return type:
Optional[Work]
torch.distributed. send_object_list (object_list , dst=None, group=None,
device=None, group_dst =None )Warning ⚠
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 26/83Sends picklable objects in object_list  synchronously.
Similar to send(), but Python objects can be passed in. Note that all objects in object_list
must be picklable in order to be sent.
Parameters:
object_list (List[Any]) – List of input objects to sent. Each object must be picklable.
Receiver must provide lists of equal sizes.
dst (int) – Destination rank to send object_list  to. Destination rank is based on
global process group (regardless of group argument)
group (Optional[ProcessGroup]) – (ProcessGroup, optional): The process group to
work on. If None, the default process group will be used. Default is None.
device (torch.device, optional) – If not None, the objects are serialized and
converted to tensors which are moved to the device before sending. Default is None
group_dst (int, optional) – Destination rank on group. Must specify one of dst and
group_dst  but not both
Returns:
None.
For NCCL-based process groups, internal tensor representations of objects must be
moved to the GPU device before communication takes place. In this case, the device
used is given by torch.cuda.current_device()  and it is the userʼs responsibility to
ensure that this is set so that each rank has an individual GPU, via
torch.cuda.set_device() .
Object collectives have a number of serious performance and scalability limitations.
See Object collectives for details.Note 
Warning ⚠
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 27/83[sourcesend_object_list()  uses pickle module implicitly, which is known to be insecure.
It is possible to construct malicious pickle data which will execute arbitrary code
during unpickling. Only call this function with data you trust.
Calling send_object_list()  with GPU tensors is not well supported and inefficient
as it incurs GPU -> CPU transfer since tensors would be pickled. Please consider
using send() instead.
Example::
torch.distributed. recv_object_list (object_list , src=None, group=None,
device=None, group_src =None )
Receives picklable objects in object_list  synchronously.
Similar to recv(), but can receive Python objects.
Parameters:
object_list (List[Any]) – List of objects to receive into. Must provide a list of sizes equa
to the size of the list being sent.
src (int, optional) – Source rank from which to recv object_list. Source rank is base
on global process group (regardless of group argument) Will receive from any rank if>>> # Note: Process group initialization omitted on each rank.
>>> import torch.distributed  as dist
>>> # Assumes backend is not NCCL
>>> device = torch.device("cpu")
>>> if dist.get_rank () == 0:
>>>     # Assumes world_size of 2.
>>>     objects = ["foo", 12, {1: 2}] # any picklable object
>>>     dist.send_object_list (objects, dst=1, device=device)
>>> else:
>>>     objects = [None, None, None]
>>>     dist.recv_object_list (objects, src=0, device=device)
>>> objects
['foo', 12, {1: 2}]Warning ⚠
Warning ⚠
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 28/83set to None. Default is None.
group (Optional[ProcessGroup]) – (ProcessGroup, optional): The process group to
work on. If None, the default process group will be used. Default is None.
device (torch.device, optional) – If not None, receives on this device. Default is
None.
group_src (int, optional) – Destination rank on group. Invalid to specify both src an
group_src.
Returns:
Sender rank. -1 if rank is not part of the group. If rank is part of the group, object_list
will contain the sent objects from src rank.
For NCCL-based process groups, internal tensor representations of objects must be
moved to the GPU device before communication takes place. In this case, the device
used is given by torch.cuda.current_device()  and it is the userʼs responsibility to
ensure that this is set so that each rank has an individual GPU, via
torch.cuda.set_device() .
Object collectives have a number of serious performance and scalability limitations.
See Object collectives for details.
recv_object_list()  uses pickle module implicitly, which is known to be insecure.
It is possible to construct malicious pickle data which will execute arbitrary code
during unpickling. Only call this function with data you trust.
Calling recv_object_list()  with GPU tensors is not well supported and inefficient
as it incurs GPU -> CPU transfer since tensors would be pickled. Please consider
using recv() instead.Note 
Warning ⚠
Warning ⚠
Warning ⚠
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 29/83[sourceExample::
torch.distributed. batch_isend_irecv (p2p_op_list )
Send or Receive a batch of tensors asynchronously and return a list of requests.
Process each of the operations in p2p_op_list  and return the corresponding requests. NCCL
Gloo, and UCC backend are currently supported.
Parameters:
p2p_op_list (list[torch.distributed.distributed_c10d.P2POp]) – A list of point-to-point
operations(type of each operator is torch.distributed.P2POp ). The order of the
isend/irecv in the list matters and it needs to match with corresponding isend/irecv on the
remote end.
Returns:
A list of distributed request objects returned by calling the corresponding op in the
op_list.
Return type:
list[torch.distributed.distributed_c10d.Work]
Examples>>> # Note: Process group initialization omitted on each rank.
>>> import torch.distributed  as dist
>>> # Assumes backend is not NCCL
>>> device = torch.device("cpu")
>>> if dist.get_rank () == 0:
>>>     # Assumes world_size of 2.
>>>     objects = ["foo", 12, {1: 2}] # any picklable object
>>>     dist.send_object_list (objects, dst=1, device=device)
>>> else:
>>>     objects = [None, None, None]
>>>     dist.recv_object_list (objects, src=0, device=device)
>>> objects
['foo', 12, {1: 2}]
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 30/83[sourceNote that when this API is used with the NCCL PG backend, users must set the
current GPU device with torch.cuda.set_device, otherwise it will lead to unexpected
hang issues.
In addition, if this API is the first collective call in the group passed to dist.P2POp,
all ranks of the group must participate in this API call; otherwise, the behavior is
undefined. If this API call is not the first collective call in the group, batched P2P
operations involving only a subset of ranks of the group are allowed.
class torch.distributed. P2POp (op, tensor, peer=None, group=None, tag=0,
group_peer =None )
A class to build point-to-point operations for batch_isend_irecv.
This class builds the type of P2P operation, communication buffer, peer rank, Process Group,
and tag. Instances of this class will be passed to batch_isend_irecv  for point-to-point
communications.
Parameters:
op (Callable) – A function to send data to or receive data from a peer process. The typ
of op is either torch.distributed.isend  or torch.distributed.irecv .
tensor (Tensor) – Tensor to send or receive.
peer (int, optional) – Destination or source rank.>>> send_tensor  = torch.arange(2, dtype=torch.float32) + 2 * rank
>>> recv_tensor  = torch.randn(2, dtype=torch.float32)
>>> send_op = dist.P2POp(dist.isend, send_tensor , (rank + 1) % world_size )
>>> recv_op = dist.P2POp(
...     dist.irecv, recv_tensor , (rank - 1 + world_size ) % world_size
... )
>>> reqs = batch_isend_irecv ([send_op, recv_op])
>>> for req in reqs:
>>>     req.wait()
>>> recv_tensor
tensor([2, 3])     # Rank 0
tensor([0, 1])     # Rank 1
Note 
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 31/83group (ProcessGroup, optional) – The process group to work on. If None, the default
process group will be used.
tag (int, optional) – Tag to match send with recv.
group_peer (int, optional) – Destination or source rank.
Synchronous and asynchronous collective
operations
Every collective operation function supports the following two kinds of operations, depending on
the setting of the async_op  flag passed into the collective:
Synchronous operation - the default mode, when async_op  is set to False. When the function
returns, it is guaranteed that the collective operation is performed. In the case of CUDA operations
it is not guaranteed that the CUDA operation is completed, since CUDA operations are
asynchronous. For CPU collectives, any further function calls utilizing the output of the collective
call will behave as expected. For CUDA collectives, function calls utilizing the output on the same
CUDA stream will behave as expected. Users must take care of synchronization under the scenario
of running under different streams. For details on CUDA semantics such as stream synchronization
see CUDA Semantics. See the below script to see examples of differences in these semantics for
CPU and CUDA operations.
Asynchronous operation - when async_op  is set to True. The collective operation function
returns a distributed request object. In general, you donʼt need to create it manually and it is
guaranteed to support two methods:
is_completed()  - in the case of CPU collectives, returns True if completed. In the case of
CUDA operations, returns True if the operation has been successfully enqueued onto a CUDA
stream and the output can be utilized on the default stream without further synchronization.
wait() - in the case of CPU collectives, will block the process until the operation is
completed. In the case of CUDA collectives, will block the currently active CUDA stream until
the operation is completed (but will not block the CPU).
get_future()  - returns torch._C.Future  object. Supported for NCCL, also supported for
most operations on GLOO and MPI, except for peer to peer operations. Note: as we continue
adopting Futures and merging APIs, get_future()  call might become redundant.
ExampleTo analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 32/83[sourceThe following code can serve as a reference regarding semantics for CUDA operations when using
distributed collectives. It shows the explicit need to synchronize when using collective outputs on
different CUDA streams:
Collective functions
torch.distributed. broadcast (tensor, src=None, group=None, async_op =False,
group_src =None )
Broadcasts the tensor to the whole group.
tensor must have the same number of elements in all processes participating in the collectiv
Parameters:
tensor (Tensor) – Data to be sent if src is the rank of current process, and tensor to
be used to save received data otherwise.
src (int) – Source rank on global process group (regardless of group argument).
group (ProcessGroup, optional) – The process group to work on. If None, the default
process group will be used.
async_op (bool, optional) – Whether this op should be an async op
group_src (int) – Source rank on group. Must specify one of group_src  and src
but not both.
Returns:# Code runs on each rank.
dist.init_process_group ("nccl", rank=rank, world_size =2)
output = torch.tensor([rank]).cuda(rank)
s = torch.cuda.Stream()
handle = dist.all_reduce (output, async_op =True)
# Wait ensures the operation is enqueued, but not necessarily complete.
handle.wait()
# Using result on non-default stream.
with torch.cuda.stream(s):
    s.wait_stream (torch.cuda.default_stream ())
    output.add_(100)
if rank == 0:
    # if the explicit call to wait_stream was omitted, the output below will be
    # non-deterministically 1 or 101, depending on whether the allreduce overwrote
    # the value after the add completed.
    print(output)
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 33/83[sourceAsync work handle, if async_op is set to True. None, if not async_op or if not part of the
group
torch.distributed. broadcast_object_list (object_list , src=None,
group=None, device=None, group_src =None )
Broadcasts picklable objects in object_list  to the whole group.
Similar to broadcast(), but Python objects can be passed in. Note that all objects in
object_list  must be picklable in order to be broadcasted.
Parameters:
object_list (List[Any]) – List of input objects to broadcast. Each object must be
picklable. Only objects on the src rank will be broadcast, but each rank must provide
lists of equal sizes.
src (int) – Source rank from which to broadcast object_list. Source rank is based o
global process group (regardless of group argument)
group (Optional[ProcessGroup]) – (ProcessGroup, optional): The process group to
work on. If None, the default process group will be used. Default is None.
device (torch.device, optional) – If not None, the objects are serialized and
converted to tensors which are moved to the device before broadcasting. Default is
None.
group_src (int) – Source rank on group. Must not specify one of group_src  and sr
but not both.
Returns:
None. If rank is part of the group, object_list  will contain the broadcasted objects
from src rank.
For NCCL-based process groups, internal tensor representations of objects must be
moved to the GPU device before communication takes place. In this case, the device
used is given by torch.cuda.current_device()  and it is the userʼs responsibility to
ensure that this is set so that each rank has an individual GPU, via
torch.cuda.set_device() .Note 
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 34/83Note that this API differs slightly from the broadcast()  collective since it does not
provide an async_op  handle and thus will be a blocking call.
Object collectives have a number of serious performance and scalability limitations.
See Object collectives for details.
broadcast_object_list()  uses pickle module implicitly, which is known to be
insecure. It is possible to construct malicious pickle data which will execute arbitrary
code during unpickling. Only call this function with data you trust.
Calling broadcast_object_list()  with GPU tensors is not well supported and
inefficient as it incurs GPU -> CPU transfer since tensors would be pickled. Please
consider using broadcast()  instead.
Example::
>>> # Note: Process group initialization omitted on each rank.
>>> import torch.distributed  as dist
>>> if dist.get_rank () == 0:
>>>     # Assumes world_size of 3.
>>>     objects = ["foo", 12, {1: 2}] # any picklable object
>>> else:
>>>     objects = [None, None, None]
>>> # Assumes backend is not NCCL
>>> device = torch.device("cpu")
>>> dist.broadcast_object_list (objects, src=0, device=device)
>>> objects
['foo', 12, {1: 2}]Note 
Warning ⚠
Warning ⚠
Warning ⚠
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 35/83[sourcetorch.distributed. all_reduce (tensor, op=<RedOpType.SUM:  0>, group=None ,
async_op=False )
Reduces the tensor data across all machines in a way that all get the final result.
After the call tensor is going to be bitwise identical in all processes.
Complex tensors are supported.
Parameters:
tensor (Tensor) – Input and output of the collective. The function operates in-place.
op (optional) – One of the values from torch.distributed.ReduceOp  enum. Specifies
an operation used for element-wise reductions.
group (ProcessGroup, optional) – The process group to work on. If None, the default
process group will be used.
async_op (bool, optional) – Whether this op should be an async op
Returns:
Async work handle, if async_op is set to True. None, if not async_op or if not part of the
group
Examples
>>> # All tensors below are of torch.int64 type.
>>> # We have 2 process groups, 2 ranks.
>>> device = torch.device(f"cuda:{rank}")
>>> tensor = torch.arange(2, dtype=torch.int64, device=device) + 1 + 2 * rank
>>> tensor
tensor([1, 2], device='cuda:0') # Rank 0
tensor([3, 4], device='cuda:1') # Rank 1
>>> dist.all_reduce (tensor, op=ReduceOp .SUM)
>>> tensor
tensor([4, 6], device='cuda:0') # Rank 0
tensor([4, 6], device='cuda:1') # Rank 1
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 36/83[source
[sourcetorch.distributed. reduce (tensor, dst=None , op=<RedOpType.SUM:  0>,
group=None , async_op=False , group_dst=None )
Reduces the tensor data across all machines.
Only the process with rank dst is going to receive the final result.
Parameters:
tensor (Tensor) – Input and output of the collective. The function operates in-place.
dst (int) – Destination rank on global process group (regardless of group argument)
op (optional) – One of the values from torch.distributed.ReduceOp  enum. Specifies
an operation used for element-wise reductions.
group (ProcessGroup, optional) – The process group to work on. If None, the default
process group will be used.
async_op (bool, optional) – Whether this op should be an async op
group_dst (int) – Destination rank on group. Must specify one of group_dst  and
dst but not both.
Returns:
Async work handle, if async_op is set to True. None, if not async_op or if not part of the
group
torch.distributed. all_gather (tensor_list , tensor, group=None,
async_op =False )
Gathers tensors from the whole group in a list.>>> # All tensors below are of torch.cfloat type.
>>> # We have 2 process groups, 2 ranks.
>>> tensor = torch.tensor(
...     [1 + 1j, 2 + 2j], dtype=torch.cfloat, device=device
... ) + 2 * rank * (1 + 1j)
>>> tensor
tensor([1.+1.j, 2.+2.j], device='cuda:0') # Rank 0
tensor([3.+3.j, 4.+4.j], device='cuda:1') # Rank 1
>>> dist.all_reduce (tensor, op=ReduceOp .SUM)
>>> tensor
tensor([4.+4.j, 6.+6.j], device='cuda:0') # Rank 0
tensor([4.+4.j, 6.+6.j], device='cuda:1') # Rank 1
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 37/83Complex and uneven sized tensors are supported.
Parameters:
tensor_list (list[Tensor]) – Output list. It should contain correctly-sized tensors to be
used for output of the collective. Uneven sized tensors are supported.
tensor (Tensor) – Tensor to be broadcast from current process.
group (ProcessGroup, optional) – The process group to work on. If None, the default
process group will be used.
async_op (bool, optional) – Whether this op should be an async op
Returns:
Async work handle, if async_op is set to True. None, if not async_op or if not part of the
group
Examples
>>> # All tensors below are of torch.int64 dtype.
>>> # We have 2 process groups, 2 ranks.
>>> device = torch.device(f"cuda:{rank}")
>>> tensor_list  = [
...     torch.zeros(2, dtype=torch.int64, device=device) for _ in range(2)
... ]
>>> tensor_list
[tensor([0, 0], device='cuda:0'), tensor([0, 0], device='cuda:0')] # Rank 0
[tensor([0, 0], device='cuda:1'), tensor([0, 0], device='cuda:1')] # Rank 1
>>> tensor = torch.arange(2, dtype=torch.int64, device=device) + 1 + 2 * rank
>>> tensor
tensor([1, 2], device='cuda:0') # Rank 0
tensor([3, 4], device='cuda:1') # Rank 1
>>> dist.all_gather (tensor_list , tensor)
>>> tensor_list
[tensor([1, 2], device='cuda:0'), tensor([3, 4], device='cuda:0')] # Rank 0
[tensor([1, 2], device='cuda:1'), tensor([3, 4], device='cuda:1')] # Rank 1
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 38/83[sourcetorch.distributed. all_gather_into_tensor (output_tensor , input_tensor ,
group=None, async_op =False )
Gather tensors from all ranks and put them in a single output tensor.
This function requires all tensors to be the same size on each process.
Parameters:
output_tensor (Tensor) – Output tensor to accommodate tensor elements from all
ranks. It must be correctly sized to have one of the following forms: (i) a concatenation
of all the input tensors along the primary dimension; for definition of “concatenation”,
see torch.cat(); (ii) a stack of all the input tensors along the primary dimension; for
definition of “stack”, see torch.stack(). Examples below may better explain the
supported output forms.
input_tensor (Tensor) – Tensor to be gathered from current rank. Different from the
all_gather  API, the input tensors in this API must have the same size across all ranks
group (ProcessGroup, optional) – The process group to work on. If None, the default
process group will be used.
async_op (bool, optional) – Whether this op should be an async op
Returns:>>> # All tensors below are of torch.cfloat dtype.
>>> # We have 2 process groups, 2 ranks.
>>> tensor_list  = [
...     torch.zeros(2, dtype=torch.cfloat, device=device) for _ in range(2)
... ]
>>> tensor_list
[tensor([0.+0.j, 0.+0.j], device='cuda:0'), tensor([0.+0.j, 0.+0.j], device='cu
[tensor([0.+0.j, 0.+0.j], device='cuda:1'), tensor([0.+0.j, 0.+0.j], device='cu
>>> tensor = torch.tensor(
...     [1 + 1j, 2 + 2j], dtype=torch.cfloat, device=device
... ) + 2 * rank * (1 + 1j)
>>> tensor
tensor([1.+1.j, 2.+2.j], device='cuda:0') # Rank 0
tensor([3.+3.j, 4.+4.j], device='cuda:1') # Rank 1
>>> dist.all_gather (tensor_list , tensor)
>>> tensor_list
[tensor([1.+1.j, 2.+2.j], device='cuda:0'), tensor([3.+3.j, 4.+4.j], device='cu
[tensor([1.+1.j, 2.+2.j], device='cuda:1'), tensor([3.+3.j, 4.+4.j], device='cu
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 39/83[sourceAsync work handle, if async_op is set to True. None, if not async_op or if not part of the
group
Examples
torch.distributed. all_gather_object (object_list , obj,
group=None )
Gathers picklable objects from the whole group into a list.
Similar to all_gather(), but Python objects can be passed in. Note that the object must be
picklable in order to be gathered.
Parameters:
object_list (list[Any]) – Output list. It should be correctly sized as the size of the group
for this collective and will contain the output.
obj (Any) – Pickable Python object to be broadcast from current process.
group (ProcessGroup, optional) – The process group to work on. If None, the default
process group will be used. Default is None.
Returns:>>> # All tensors below are of torch.int64 dtype and on CUDA devices.
>>> # We have two ranks.
>>> device = torch.device(f"cuda:{rank}")
>>> tensor_in  = torch.arange(2, dtype=torch.int64, device=device) + 1 + 2 * ran
>>> tensor_in
tensor([1, 2], device='cuda:0') # Rank 0
tensor([3, 4], device='cuda:1') # Rank 1
>>> # Output in concatenation form
>>> tensor_out  = torch.zeros(world_size  * 2, dtype=torch.int64, device=device)
>>> dist.all_gather_into_tensor (tensor_out , tensor_in )
>>> tensor_out
tensor([1, 2, 3, 4], device='cuda:0') # Rank 0
tensor([1, 2, 3, 4], device='cuda:1') # Rank 1
>>> # Output in stack form
>>> tensor_out2  = torch.zeros(world_size , 2, dtype=torch.int64, device=device)
>>> dist.all_gather_into_tensor (tensor_out2 , tensor_in )
>>> tensor_out2
tensor([[1, 2],
        [3, 4]], device='cuda:0') # Rank 0
tensor([[1, 2],
        [3, 4]], device='cuda:1') # Rank 1
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 40/83None. If the calling rank is part of this group, the output of the collective will be populated
into the input object_list. If the calling rank is not part of the group, the passed in
object_list  will be unmodified.
Note that this API differs slightly from the all_gather()  collective since it does not
provide an async_op  handle and thus will be a blocking call.
For NCCL-based processed groups, internal tensor representations of objects must
be moved to the GPU device before communication takes place. In this case, the
device used is given by torch.cuda.current_device()  and it is the userʼs
responsibility to ensure that this is set so that each rank has an individual GPU, via
torch.cuda.set_device() .
Object collectives have a number of serious performance and scalability limitations.
See Object collectives for details.
all_gather_object()  uses pickle module implicitly, which is known to be
insecure. It is possible to construct malicious pickle data which will execute arbitrary
code during unpickling. Only call this function with data you trust.
Calling all_gather_object()  with GPU tensors is not well supported and inefficient
as it incurs GPU -> CPU transfer since tensors would be pickled. Please consider
using all_gather()  instead.
Example::Note 
Note 
Warning ⚠
Warning ⚠
Warning ⚠
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 41/83[sourcetorch.distributed. gather (tensor, gather_list =None, dst=None, group=None,
async_op =False, group_dst =None )
Gathers a list of tensors in a single process.
This function requires all tensors to be the same size on each process.
Parameters:
tensor (Tensor) – Input tensor.
gather_list (list[Tensor], optional) – List of appropriately, same-sized tensors to use fo
gathered data (default is None, must be specified on the destination rank)
dst (int, optional) – Destination rank on global process group (regardless of group
argument). (If both dst and group_dst  are None, default is global rank 0)
group (ProcessGroup, optional) – The process group to work on. If None, the default
process group will be used.
async_op (bool, optional) – Whether this op should be an async op
group_dst (int, optional) – Destination rank on group. Invalid to specify both dst an
group_dst
Returns:
Async work handle, if async_op is set to True. None, if not async_op or if not part of the
group
Note that all Tensors in gather_list must have the same size.
Example::>>> # Note: Process group initialization omitted on each rank.
>>> import torch.distributed  as dist
>>> # Assumes world_size of 3.
>>> gather_objects  = ["foo", 12, {1: 2}] # any picklable object
>>> output = [None for _ in gather_objects ]
>>> dist.all_gather_object (output, gather_objects [dist.get_rank ()])
>>> output
['foo', 12, {1: 2}]
Note 
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 42/83[sourcetorch.distributed. gather_object (obj, object_gather_list =None, dst=None,
group=None, group_dst =None )
Gathers picklable objects from the whole group in a single process.
Similar to gather(), but Python objects can be passed in. Note that the object must be
picklable in order to be gathered.
Parameters:
obj (Any) – Input object. Must be picklable.
object_gather_list (list[Any]) – Output list. On the dst rank, it should be correctly
sized as the size of the group for this collective and will contain the output. Must be
None on non-dst ranks. (default is None)
dst (int, optional) – Destination rank on global process group (regardless of group
argument). (If both dst and group_dst  are None, default is global rank 0)
group (Optional[ProcessGroup]) – (ProcessGroup, optional): The process group to
work on. If None, the default process group will be used. Default is None.
group_dst (int, optional) – Destination rank on group. Invalid to specify both dst an
group_dst
Returns:
None. On the dst rank, object_gather_list  will contain the output of the collective.>>> # We have 2 process groups, 2 ranks.
>>> tensor_size  = 2
>>> device = torch.device(f'cuda:{rank}')
>>> tensor = torch.ones(tensor_size , device=device) + rank
>>> if dist.get_rank () == 0:
>>>     gather_list  = [torch.zeros_like (tensor, device=device) for i in ran
>>> else:
>>>     gather_list  = None
>>> dist.gather(tensor, gather_list , dst=0)
>>> # Rank 0 gets gathered data.
>>> gather_list
[tensor([1., 1.], device='cuda:0'), tensor([2., 2.], device='cuda:0')] # Ra
None                                                                   # Ra
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 43/83Note that this API differs slightly from the gather collective since it does not provide
an async_op handle and thus will be a blocking call.
For NCCL-based processed groups, internal tensor representations of objects must
be moved to the GPU device before communication takes place. In this case, the
device used is given by torch.cuda.current_device()  and it is the userʼs
responsibility to ensure that this is set so that each rank has an individual GPU, via
torch.cuda.set_device() .
Object collectives have a number of serious performance and scalability limitations.
See Object collectives for details.
gather_object()  uses pickle module implicitly, which is known to be insecure. It is
possible to construct malicious pickle data which will execute arbitrary code during
unpickling. Only call this function with data you trust.
Calling gather_object()  with GPU tensors is not well supported and inefficient as it
incurs GPU -> CPU transfer since tensors would be pickled. Please consider using
gather()  instead.
Example::Note 
Note 
Warning ⚠
Warning ⚠
Warning ⚠
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 44/83[sourcetorch.distributed. scatter (tensor, scatter_list =None, src=None, group=None
async_op =False, group_src =None )
Scatters a list of tensors to all processes in a group.
Each process will receive exactly one tensor and store its data in the tensor argument.
Complex tensors are supported.
Parameters:
tensor (Tensor) – Output tensor.
scatter_list (list[Tensor]) – List of tensors to scatter (default is None, must be specifie
on the source rank)
src (int) – Source rank on global process group (regardless of group argument). (If
both src and group_src  are None, default is global rank 0)
group (ProcessGroup, optional) – The process group to work on. If None, the default
process group will be used.
async_op (bool, optional) – Whether this op should be an async op
group_src (int, optional) – Source rank on group. Invalid to specify both src and
group_src
Returns:
Async work handle, if async_op is set to True. None, if not async_op or if not part of the
group>>> # Note: Process group initialization omitted on each rank.
>>> import torch.distributed  as dist
>>> # Assumes world_size of 3.
>>> gather_objects  = ["foo", 12, {1: 2}] # any picklable object
>>> output = [None for _ in gather_objects ]
>>> dist.gather_object (
...     gather_objects [dist.get_rank ()],
...     output if dist.get_rank () == 0 else None,
...     dst=0
... )
>>> # On rank 0
>>> output
['foo', 12, {1: 2}]
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 45/83[sourceNote that all Tensors in scatter_list must have the same size.
Example::
torch.distributed. scatter_object_list (scatter_object_output_list ,
scatter_object_input_list =None, src=None, group=None, group_src =None )
Scatters picklable objects in scatter_object_input_list  to the whole group.
Similar to scatter(), but Python objects can be passed in. On each rank, the scattered objec
will be stored as the first element of scatter_object_output_list . Note that all objects in
scatter_object_input_list  must be picklable in order to be scattered.
Parameters:
scatter_object_output_list (List[Any]) – Non-empty list whose first element will store
the object scattered to this rank.
scatter_object_input_list (List[Any], optional) – List of input objects to scatter. Each
object must be picklable. Only objects on the src rank will be scattered, and the
argument can be None for non-src ranks.
src (int) – Source rank from which to scatter scatter_object_input_list . Source
rank is based on global process group (regardless of group argument). (If both src>>> # Note: Process group initialization omitted on each rank.
>>> import torch.distributed  as dist
>>> tensor_size  = 2
>>> device = torch.device(f'cuda:{rank}')
>>> output_tensor  = torch.zeros(tensor_size , device=device)
>>> if dist.get_rank () == 0:
>>>     # Assumes world_size of 2.
>>>     # Only tensors, all of which must be the same size.
>>>     t_ones = torch.ones(tensor_size , device=device)
>>>     t_fives = torch.ones(tensor_size , device=device) * 5
>>>     scatter_list  = [t_ones, t_fives]
>>> else:
>>>     scatter_list  = None
>>> dist.scatter(output_tensor , scatter_list , src=0)
>>> # Rank i gets scatter_list[i].
>>> output_tensor
tensor([1., 1.], device='cuda:0') # Rank 0
tensor([5., 5.], device='cuda:1') # Rank 1Note 
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 46/83and group_src  are None, default is global rank 0)
group (Optional[ProcessGroup]) – (ProcessGroup, optional): The process group to
work on. If None, the default process group will be used. Default is None.
group_src (int, optional) – Source rank on group. Invalid to specify both src and
group_src
Returns:
None. If rank is part of the group, scatter_object_output_list  will have its first
element set to the scattered object for this rank.
Note that this API differs slightly from the scatter collective since it does not provide
an async_op  handle and thus will be a blocking call.
Object collectives have a number of serious performance and scalability limitations.
See Object collectives for details.
scatter_object_list()  uses pickle module implicitly, which is known to be
insecure. It is possible to construct malicious pickle data which will execute arbitrary
code during unpickling. Only call this function with data you trust.
Calling scatter_object_list()  with GPU tensors is not well supported and
inefficient as it incurs GPU -> CPU transfer since tensors would be pickled. Please
consider using scatter()  instead.
Example::Note 
Warning ⚠
Warning ⚠
Warning ⚠
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 47/83[source
[sourcetorch.distributed. reduce_scatter (output, input_list , op=<RedOpType.SUM:
0>, group=None , async_op=False )
Reduces, then scatters a list of tensors to all processes in a group.
Parameters:
output (Tensor) – Output tensor.
input_list (list[Tensor]) – List of tensors to reduce and scatter.
op (optional) – One of the values from torch.distributed.ReduceOp  enum. Specifies
an operation used for element-wise reductions.
group (ProcessGroup, optional) – The process group to work on. If None, the default
process group will be used.
async_op (bool, optional) – Whether this op should be an async op.
Returns:
Async work handle, if async_op is set to True. None, if not async_op or if not part of the
group.
torch.distributed. reduce_scatter_tensor (output, input,
op=<RedOpType.SUM:  0>, group=None , async_op=False )
Reduces, then scatters a tensor to all ranks in a group.
Parameters:
output (Tensor) – Output tensor. It should have the same size across all ranks.>>> # Note: Process group initialization omitted on each rank.
>>> import torch.distributed  as dist
>>> if dist.get_rank () == 0:
>>>     # Assumes world_size of 3.
>>>     objects = ["foo", 12, {1: 2}] # any picklable object
>>> else:
>>>     # Can be any list on non-src ranks, elements are not used.
>>>     objects = [None, None, None]
>>> output_list  = [None]
>>> dist.scatter_object_list (output_list , objects, src=0)
>>> # Rank i gets objects[i]. For example, on rank 2:
>>> output_list
[{1: 2}]
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 48/83[sourceinput (Tensor) – Input tensor to be reduced and scattered. Its size should be output
tensor size times the world size. The input tensor can have one of the following shapes
(i) a concatenation of the output tensors along the primary dimension, or (ii) a stack of
the output tensors along the primary dimension. For definition of “concatenation”, see
torch.cat(). For definition of “stack”, see torch.stack().
group (ProcessGroup, optional) – The process group to work on. If None, the default
process group will be used.
async_op (bool, optional) – Whether this op should be an async op.
Returns:
Async work handle, if async_op is set to True. None, if not async_op or if not part of the
group.
Examples
torch.distributed. all_to_all_single (output, input,
output_split_sizes =None, input_split_sizes =None, group=None,
async_op =False )>>> # All tensors below are of torch.int64 dtype and on CUDA devices.
>>> # We have two ranks.
>>> device = torch.device(f"cuda:{rank}")
>>> tensor_out  = torch.zeros(2, dtype=torch.int64, device=device)
>>> # Input in concatenation form
>>> tensor_in  = torch.arange(world_size  * 2, dtype=torch.int64, device=device)
>>> tensor_in
tensor([0, 1, 2, 3], device='cuda:0') # Rank 0
tensor([0, 1, 2, 3], device='cuda:1') # Rank 1
>>> dist.reduce_scatter_tensor (tensor_out , tensor_in )
>>> tensor_out
tensor([0, 2], device='cuda:0') # Rank 0
tensor([4, 6], device='cuda:1') # Rank 1
>>> # Input in stack form
>>> tensor_in  = torch.reshape(tensor_in , (world_size , 2))
>>> tensor_in
tensor([[0, 1],
        [2, 3]], device='cuda:0') # Rank 0
tensor([[0, 1],
        [2, 3]], device='cuda:1') # Rank 1
>>> dist.reduce_scatter_tensor (tensor_out , tensor_in )
>>> tensor_out
tensor([0, 2], device='cuda:0') # Rank 0
tensor([4, 6], device='cuda:1') # Rank 1
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 49/83Split input tensor and then scatter the split list to all processes in a group.
Later the received tensors are concatenated from all the processes in the group and returned
as a single output tensor.
Complex tensors are supported.
Parameters:
output (Tensor) – Gathered concatenated output tensor.
input (Tensor) – Input tensor to scatter.
output_split_sizes – (list[Int], optional): Output split sizes for dim 0 if specified None
or empty, dim 0 of output tensor must divide equally by world_size.
input_split_sizes – (list[Int], optional): Input split sizes for dim 0 if specified None or
empty, dim 0 of input tensor must divide equally by world_size.
group (ProcessGroup, optional) – The process group to work on. If None, the default
process group will be used.
async_op (bool, optional) – Whether this op should be an async op.
Returns:
Async work handle, if async_op is set to True. None, if not async_op or if not part of the
group.
all_to_all_single is experimental and subject to change.
Examples
>>> input = torch.arange(4) + rank * 4
>>> input
tensor([0, 1, 2, 3])     # Rank 0
tensor([4, 5, 6, 7])     # Rank 1
tensor([8, 9, 10, 11])   # Rank 2
tensor([12, 13, 14, 15]) # Rank 3
>>> output = torch.empty([4], dtype=torch.int64)
>>> dist.all_to_all_single (output, input)
>>> output
tensor([0, 4, 8, 12])    # Rank 0
tensor([1, 5, 9, 13])    # Rank 1
tensor([2, 6, 10, 14])   # Rank 2
tensor([3, 7, 11, 15])   # Rank 3Warning ⚠
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 50/83>>> # Essentially, it is similar to following operation:
>>> scatter_list  = list(input.chunk(world_size ))
>>> gather_list  = list(output.chunk(world_size ))
>>> for i in range(world_size ):
>>>     dist.scatter(gather_list [i], scatter_list  if i == rank else [], src = i
>>> # Another example with uneven split
>>> input
tensor([0, 1, 2, 3, 4, 5])                                       # Rank 0
tensor([10, 11, 12, 13, 14, 15, 16, 17, 18])                     # Rank 1
tensor([20, 21, 22, 23, 24])                                     # Rank 2
tensor([30, 31, 32, 33, 34, 35, 36])                             # Rank 3
>>> input_splits
[2, 2, 1, 1]                                                     # Rank 0
[3, 2, 2, 2]                                                     # Rank 1
[2, 1, 1, 1]                                                     # Rank 2
[2, 2, 2, 1]                                                     # Rank 3
>>> output_splits
[2, 3, 2, 2]                                                     # Rank 0
[2, 2, 1, 2]                                                     # Rank 1
[1, 2, 1, 2]                                                     # Rank 2
[1, 2, 1, 1]                                                     # Rank 3
>>> output = ...
>>> dist.all_to_all_single (output, input, output_splits , input_splits )
>>> output
tensor([ 0,  1, 10, 11, 12, 20, 21, 30, 31])                     # Rank 0
tensor([ 2,  3, 13, 14, 22, 32, 33])                             # Rank 1
tensor([ 4, 15, 16, 23, 34, 35])                                 # Rank 2
tensor([ 5, 17, 18, 24, 36])                                     # Rank 3
>>> # Another example with tensors of torch.cfloat type.
>>> input = torch.tensor(
...     [1 + 1j, 2 + 2j, 3 + 3j, 4 + 4j], dtype=torch.cfloat
... ) + 4 * rank * (1 + 1j)
>>> input
tensor([1+1j, 2+2j, 3+3j, 4+4j])                                # Rank 0
tensor([5+5j, 6+6j, 7+7j, 8+8j])                                # Rank 1
tensor([9+9j, 10+10j, 11+11j, 12+12j])                          # Rank 2
tensor([13+13j, 14+14j, 15+15j, 16+16j])                        # Rank 3
>>> output = torch.empty([4], dtype=torch.int64)
>>> dist.all_to_all_single (output, input)
>>> output
tensor([1+1j, 5+5j, 9+9j, 13+13j])                              # Rank 0
tensor([2+2j, 6+6j, 10+10j, 14+14j])                            # Rank 1
tensor([3+3j, 7+7j, 11+11j, 15+15j])                            # Rank 2
tensor([4+4j, 8+8j, 12+12j, 16+16j])                            # Rank 3To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 51/83[sourcetorch.distributed. all_to_all (output_tensor_list , input_tensor_list ,
group=None, async_op =False )
Scatters list of input tensors to all processes in a group and return gathered list of tensors in
output list.
Complex tensors are supported.
Parameters:
output_tensor_list (list[Tensor]) – List of tensors to be gathered one per rank.
input_tensor_list (list[Tensor]) – List of tensors to scatter one per rank.
group (ProcessGroup, optional) – The process group to work on. If None, the default
process group will be used.
async_op (bool, optional) – Whether this op should be an async op.
Returns:
Async work handle, if async_op is set to True. None, if not async_op or if not part of the
group.
all_to_all is experimental and subject to change.
Examples
>>> input = torch.arange(4) + rank * 4
>>> input = list(input.chunk(4))
>>> input
[tensor([0]), tensor([1]), tensor([2]), tensor([3])]     # Rank 0
[tensor([4]), tensor([5]), tensor([6]), tensor([7])]     # Rank 1
[tensor([8]), tensor([9]), tensor([10]), tensor([11])]   # Rank 2
[tensor([12]), tensor([13]), tensor([14]), tensor([15])] # Rank 3
>>> output = list(torch.empty([4], dtype=torch.int64).chunk(4))
>>> dist.all_to_all (output, input)
>>> output
[tensor([0]), tensor([4]), tensor([8]), tensor([12])]    # Rank 0
[tensor([1]), tensor([5]), tensor([9]), tensor([13])]    # Rank 1
[tensor([2]), tensor([6]), tensor([10]), tensor([14])]   # Rank 2
[tensor([3]), tensor([7]), tensor([11]), tensor([15])]   # Rank 3Warning ⚠
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 52/83>>> # Essentially, it is similar to following operation:
>>> scatter_list  = input
>>> gather_list  = output
>>> for i in range(world_size ):
>>>     dist.scatter(gather_list [i], scatter_list  if i == rank else [], src=i)
>>> input
tensor([0, 1, 2, 3, 4, 5])                                       # Rank 0
tensor([10, 11, 12, 13, 14, 15, 16, 17, 18])                     # Rank 1
tensor([20, 21, 22, 23, 24])                                     # Rank 2
tensor([30, 31, 32, 33, 34, 35, 36])                             # Rank 3
>>> input_splits
[2, 2, 1, 1]                                                     # Rank 0
[3, 2, 2, 2]                                                     # Rank 1
[2, 1, 1, 1]                                                     # Rank 2
[2, 2, 2, 1]                                                     # Rank 3
>>> output_splits
[2, 3, 2, 2]                                                     # Rank 0
[2, 2, 1, 2]                                                     # Rank 1
[1, 2, 1, 2]                                                     # Rank 2
[1, 2, 1, 1]                                                     # Rank 3
>>> input = list(input.split(input_splits ))
>>> input
[tensor([0, 1]), tensor([2, 3]), tensor([4]), tensor([5])]                   # 
[tensor([10, 11, 12]), tensor([13, 14]), tensor([15, 16]), tensor([17, 18])] # 
[tensor([20, 21]), tensor([22]), tensor([23]), tensor([24])]                 # 
[tensor([30, 31]), tensor([32, 33]), tensor([34, 35]), tensor([36])]         # 
>>> output = ...
>>> dist.all_to_all (output, input)
>>> output
[tensor([0, 1]), tensor([10, 11, 12]), tensor([20, 21]), tensor([30, 31])]   # 
[tensor([2, 3]), tensor([13, 14]), tensor([22]), tensor([32, 33])]           # 
[tensor([4]), tensor([15, 16]), tensor([23]), tensor([34, 35])]              # 
[tensor([5]), tensor([17, 18]), tensor([24]), tensor([36])]                  # 
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 53/83[sourcetorch.distributed. barrier (group=None, async_op =False, device_ids =None )
Synchronize all processes.
This collective blocks processes until the whole group enters this function, if async_op is False
or if async work handle is called on wait().
Parameters:
group (ProcessGroup, optional) – The process group to work on. If None, the default
process group will be used.
async_op (bool, optional) – Whether this op should be an async op
device_ids ([int], optional) – List of device/GPU ids. Only one id is expected.
Returns:
Async work handle, if async_op is set to True. None, if not async_op or if not part of the
group
ProcessGroupNCCL now blocks the cpu thread till the completion of the barrier
collective.>>> # Another example with tensors of torch.cfloat type.
>>> input = torch.tensor(
...     [1 + 1j, 2 + 2j, 3 + 3j, 4 + 4j], dtype=torch.cfloat
... ) + 4 * rank * (1 + 1j)
>>> input = list(input.chunk(4))
>>> input
[tensor([1+1j]), tensor([2+2j]), tensor([3+3j]), tensor([4+4j])]            # R
[tensor([5+5j]), tensor([6+6j]), tensor([7+7j]), tensor([8+8j])]            # R
[tensor([9+9j]), tensor([10+10j]), tensor([11+11j]), tensor([12+12j])]      # R
[tensor([13+13j]), tensor([14+14j]), tensor([15+15j]), tensor([16+16j])]    # R
>>> output = list(torch.empty([4], dtype=torch.int64).chunk(4))
>>> dist.all_to_all (output, input)
>>> output
[tensor([1+1j]), tensor([5+5j]), tensor([9+9j]), tensor([13+13j])]          # R
[tensor([2+2j]), tensor([6+6j]), tensor([10+10j]), tensor([14+14j])]        # R
[tensor([3+3j]), tensor([7+7j]), tensor([11+11j]), tensor([15+15j])]        # R
[tensor([4+4j]), tensor([8+8j]), tensor([12+12j]), tensor([16+16j])]        # R
Note 
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 54/83[sourcetorch.distributed. monitored_barrier (group=None, timeout=None,
wait_all_ranks =False )
Synchronize processes similar to torch.distributed.barrier , but consider a configurable
timeout.
It is able to report ranks that did not pass this barrier within the provided timeout. Specifically,
for non-zero ranks, will block until a send/recv is processed from rank 0. Rank 0 will block until
all send /recv from other ranks are processed, and will report failures for ranks that failed to
respond in time. Note that if one rank does not reach the monitored_barrier (for example due t
a hang), all other ranks would fail in monitored_barrier.
This collective will block all processes/ranks in the group, until the whole group exits the
function successfully, making it useful for debugging and synchronizing. However, it can have 
performance impact and should only be used for debugging or scenarios that require full
synchronization points on the host-side. For debugging purposes, this barrier can be inserted
before the applicationʼs collective calls to check if any ranks are desynchronized.
Note that this collective is only supported with the GLOO backend.
Parameters:
group (ProcessGroup, optional) – The process group to work on. If None, the default
process group will be used.
timeout (datetime.timedelta, optional) – Timeout for monitored_barrier. If None, the
default process group timeout will be used.
wait_all_ranks (bool, optional) – Whether to collect all failed ranks or not. By default,
this is False and monitored_barrier  on rank 0 will throw on the first failed rank it
encounters in order to fail fast. By setting wait_all_ranks=True monitored_barrier
will collect all failed ranks and throw an error containing information about all failed
ranks.
Returns:
None.
Example::Note 
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 55/83class torch.distributed. Work
A Work object represents the handle to a pending asynchronous operation in PyTorchʼs
distributed package. It is returned by non-blocking collective operations, such as
dist.all_reduce(tensor, async_op=True).
boxed (self: torch._C._distributed_c10d.Work ) → object
exception (self: torch._C._distributed_c10d.Work ) →
std::__exception_ptr::exception_ptr
get_future (self: torch._C._distributed_c10d.Work ) → torch.Future
Returns:
A torch.futures.Future  object which is associated with the completion of the
Work. As an example, a future object can be retrieved by fut =
process_group.allreduce(tensors).get_future() .
Example::
Below is an example of a simple allreduce DDP communication hook that uses
get_future  API to retrieve a Future associated with the completion of allreduce.>>> # Note: Process group initialization omitted on each rank.
>>> import torch.distributed  as dist
>>> if dist.get_rank () != 1:
>>>     dist.monitored_barrier () # Raises exception indicating that
>>> # rank 1 did not call into monitored_barrier.
>>> # Example with wait_all_ranks=True
>>> if dist.get_rank () == 0:
>>>     dist.monitored_barrier (wait_all_ranks =True) # Raises exception
>>> # indicating that ranks 1, 2, ... world_size - 1 did not call into
>>> # monitored_barrier.
>>> def allreduce (process_group : dist.ProcessGroup , bucket: dist.GradBu
>>>     group_to_use  = process_group  if process_group  is not None else 
>>>     tensor = bucket.buffer().div_(group_to_use .size())
>>>     return torch.distributed .all_reduce (tensor, group=group_to_use ,
>>> ddp_model .register_comm_hook (state=None, hook=allreduce )To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 56/83get_future  API supports NCCL, and partially GLOO and MPI backends (no
support for peer-to-peer operations like send/recv) and will return a
torch.futures.Future .
In the example above, allreduce  work will be done on GPU using NCCL
backend, fut.wait()  will return after synchronizing the appropriate NCCL
streams with PyTorchʼs current device streams to ensure we can have
asynchronous CUDA execution and it does not wait for the entire operation to
complete on GPU. Note that CUDAFuture  does not support
TORCH_NCCL_BLOCKING_WAIT  flag or NCCLʼs barrier(). In addition, if a callback
function was added by fut.then(), it will wait until WorkNCCLʼs NCCL streams
synchronize with ProcessGroupNCCLʼs dedicated callback stream and invoke the
callback inline after running the callback on the callback stream. fut.then()  will
return another CUDAFuture  that holds the return value of the callback and a
CUDAEvent  that recorded the callback stream.
get_future_result (self: torch._C._distributed_c10d.Work ) →
torch.Future
Returns:
A torch.futures.Future  object of int type which maps to the enum type of
WorkResult As an example, a future object can be retrieved by fut =
process_group.allreduce(tensor).get_future_result() .
Example::1. For CPU work, fut.done()  returns true when work has been
completed and value() tensors are ready.
2. For GPU work, fut.done()  returns true only whether the operation has
been enqueued.
3. For mixed CPU-GPU work (e.g. sending GPU tensors with GLOO),
fut.done()  returns true when tensors have arrived on respective
nodes, but not yet necessarily synched on respective GPUs (similarly to
GPU work).Warning ⚠
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 57/83users can use fut.wait()  to blocking wait for the completion of the work and get th
WorkResult by fut.value(). Also, users can use fut.then(call_back_func)  to
register a callback function to be called when the work is completed, without blocking
the current thread.
get_future_result  API supports NCCL
is_completed (self: torch._C._distributed_c10d.Work ) → bool
is_success (self: torch._C._distributed_c10d.Work ) → bool
result (self: torch._C._distributed_c10d.Work ) → list[torch.Tensor ]
source_rank (self: torch._C._distributed_c10d.Work ) → int
synchronize (self: torch._C._distributed_c10d.Work ) → None
static unbox (arg0: object ) → torch._C._distributed_c10d.Work
wait (self: torch._C._distributed_c10d.Work , timeout: datetime.timedelt
= datetime.timedelta(0) ) → bool
Returns:
true/false.
Example::
try:
work.wait(timeout)Warning ⚠
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 58/83except:
# some handling
In normal cases, users do not need to set the timeout. calling wait() is the same as
calling synchronize(): Letting the current stream block on the completion of the
NCCL work. However, if timeout is set, it will block the CPU thread until the NCCL
work is completed or timed out. If timeout, exception will be thrown.
class torch.distributed. ReduceOp
An enum-like class for available reduction operations: SUM, PRODUCT, MIN, MAX, BAND, BOR
BXOR, and PREMUL_SUM.
BAND, BOR, and BXOR reductions are not available when using the NCCL backend.
AVG divides values by the world size before summing across ranks. AVG is only available with
the NCCL backend, and only for NCCL versions 2.10 or later.
PREMUL_SUM  multiplies inputs by a given scalar locally before reduction. PREMUL_SUM  is only
available with the NCCL backend, and only available for NCCL versions 2.11 or later. Users are
supposed to use torch.distributed._make_nccl_premul_sum .
Additionally, MAX, MIN and PRODUCT are not supported for complex tensors.
The values of this class can be accessed as attributes, e.g., ReduceOp.SUM. They are used in
specifying strategies for reduction collectives, e.g., reduce().
This class does not support __members__  property.
class torch.distributed. reduce_op
Deprecated enum-like class for reduction operations: SUM, PRODUCT, MIN, and MAX.
ReduceOp  is recommended to use instead.Warning ⚠
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 59/83Distributed Key-Value Store
The distributed package comes with a distributed key-value store, which can be used to share
information between processes in the group as well as to initialize the distributed package in
torch.distributed.init_process_group()  (by explicitly creating the store as an alternative to
specifying init_method.) There are 3 choices for Key-Value Stores: TCPStore, FileStore, and
HashStore.
class torch.distributed. Store
Base class for all store implementations, such as the 3 provided by PyTorch distributed:
(TCPStore, FileStore, and HashStore).
__init__ (self: torch._C._distributed_c10d.Store ) → None
add (self: torch._C._distributed_c10d.Store , arg0: str, arg1: int ) →
int
The first call to add for a given key creates a counter associated with key in the store,
initialized to amount. Subsequent calls to add with the same key increment the counter
by the specified amount. Calling add() with a key that has already been set in the store
by set() will result in an exception.
Parameters:
key (str) – The key in the store whose counter will be incremented.
amount (int) – The quantity by which the counter will be incremented.
Example::
>>> import torch.distributed  as dist
>>> from datetime  import timedelta
>>> # Using TCPStore as an example, other store types can also be used
>>> store = dist.TCPStore ("127.0.0.1" , 0, 1, True, timedelta (seconds=30
>>> store.add("first_key" , 1)
>>> store.add("first_key" , 6)
>>> # Should return 7
>>> store.get("first_key" )To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 60/83append (self: torch._C._distributed_c10d.Store , arg0: str, arg1: str ) →
None
Append the key-value pair into the store based on the supplied key and value. If key
does not exists in the store, it will be created.
Parameters:
key (str) – The key to be appended to the store.
value (str) – The value associated with key to be added to the store.
Example::
check (self: torch._C._distributed_c10d.Store , arg0: list[str] ) → bool
The call to check whether a given list of keys have value stored in the store. This call
immediately returns in normal cases but still suffers from some edge deadlock cases, e.g,
calling check after TCPStore has been destroyed. Calling check() with a list of keys that
one wants to check whether stored in the store or not.
Parameters:
keys (list[str]) – The keys to query whether stored in the store.
Example::>>> import torch.distributed  as dist
>>> from datetime  import timedelta
>>> store = dist.TCPStore ("127.0.0.1" , 0, 1, True, timedelta (seconds=30
>>> store.append("first_key" , "po")
>>> store.append("first_key" , "tato")
>>> # Should return "potato"
>>> store.get("first_key" )
>>> import torch.distributed  as dist
>>> from datetime  import timedelta
>>> # Using TCPStore as an example, other store types can also be used
>>> store = dist.TCPStore ("127.0.0.1" , 0, 1, True, timedelta (seconds=30
>>> store.add("first_key" , 1)
>>> # Should return 7
>>> store.check(["first_key" ])To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 61/83clone (self: torch._C._distributed_c10d.Store ) →
torch._C._distributed_c10d.Store
Clones the store and returns a new object that points to the same underlying store. The
returned store can be used concurrently with the original object. This is intended to provid
a safe way to use a store from multiple threads by cloning one store per thread.
compare_set (self: torch._C._distributed_c10d.Store , arg0: str, arg1:
str, arg2: str ) → bytes
Inserts the key-value pair into the store based on the supplied key and performs
comparison between expected_value  and desired_value  before inserting.
desired_value  will only be set if expected_value  for the key already exists in the stor
or if expected_value  is an empty string.
Parameters:
key (str) – The key to be checked in the store.
expected_value (str) – The value associated with key to be checked before
insertion.
desired_value (str) – The value associated with key to be added to the store.
Example::
delete_key (self: torch._C._distributed_c10d.Store , arg0: str ) → bool
Deletes the key-value pair associated with key from the store. Returns true if the key was
successfully deleted, and false if it was not.>>> import torch.distributed  as dist
>>> from datetime  import timedelta
>>> store = dist.TCPStore ("127.0.0.1" , 0, 1, True, timedelta (seconds=30
>>> store.set("key", "first_value" )
>>> store.compare_set ("key", "first_value" , "second_value" )
>>> # Should return "second_value"
>>> store.get("key")
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 62/83The delete_key  API is only supported by the TCPStore  and HashStore. Using
this API with the FileStore  will result in an exception.
Parameters:
key (str) – The key to be deleted from the store
Returns:
True if key was deleted, otherwise False.
Example::
get (self: torch._C._distributed_c10d.Store , arg0: str ) → bytes
Retrieves the value associated with the given key in the store. If key is not present in th
store, the function will wait for timeout, which is defined when initializing the store,
before throwing an exception.
Parameters:
key (str) – The function will return the value associated with this key.
Returns:
Value associated with key if key is in the store.
Example::>>> import torch.distributed  as dist
>>> from datetime  import timedelta
>>> # Using TCPStore as an example, HashStore can also be used
>>> store = dist.TCPStore ("127.0.0.1" , 0, 1, True, timedelta (seconds=30
>>> store.set("first_key" )
>>> # This should return true
>>> store.delete_key ("first_key" )
>>> # This should return false
>>> store.delete_key ("bad_key" )Warning ⚠
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 63/83has_extended_api (self: torch._C._distributed_c10d.Store ) → bool
Returns true if the store supports extended operations.
multi_get (self: torch._C._distributed_c10d.Store , arg0: list[str] ) →
list[bytes]
Retrieve all values in keys. If any key in keys is not present in the store, the function will
wait for timeout
Parameters:
keys (List[str]) – The keys to be retrieved from the store.
Example::
multi_set (self: torch._C._distributed_c10d.Store , arg0: list[str],
arg1: list[str] ) → None
Inserts a list key-value pair into the store based on the supplied keys and values
Parameters:
keys (List[str]) – The keys to insert.
values (List[str]) – The values to insert.>>> import torch.distributed  as dist
>>> from datetime  import timedelta
>>> store = dist.TCPStore ("127.0.0.1" , 0, 1, True, timedelta (seconds=30
>>> store.set("first_key" , "first_value" )
>>> # Should return "first_value"
>>> store.get("first_key" )
>>> import torch.distributed  as dist
>>> from datetime  import timedelta
>>> store = dist.TCPStore ("127.0.0.1" , 0, 1, True, timedelta (seconds=30
>>> store.set("first_key" , "po")
>>> store.set("second_key" , "tato")
>>> # Should return [b"po", b"tato"]
>>> store.multi_get (["first_key" , "second_key" ])
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 64/83Example::
num_keys (self: torch._C._distributed_c10d.Store ) → int
Returns the number of keys set in the store. Note that this number will typically be one
greater than the number of keys added by set() and add() since one key is used to
coordinate all the workers using the store.
When used with the TCPStore, num_keys  returns the number of keys written to
the underlying file. If the store is destructed and another store is created with the
same file, the original keys will be retained.
Returns:
The number of keys present in the store.
Example::
queue_len (self: torch._C._distributed_c10d.Store , arg0: str ) → int
Returns the length of the specified queue.>>> import torch.distributed  as dist
>>> from datetime  import timedelta
>>> store = dist.TCPStore ("127.0.0.1" , 0, 1, True, timedelta (seconds=30
>>> store.multi_set (["first_key" , "second_key" ], ["po", "tato"])
>>> # Should return b"po"
>>> store.get("first_key" )
>>> import torch.distributed  as dist
>>> from datetime  import timedelta
>>> # Using TCPStore as an example, other store types can also be used
>>> store = dist.TCPStore ("127.0.0.1" , 0, 1, True, timedelta (seconds=30
>>> store.set("first_key" , "first_value" )
>>> # This should return 2
>>> store.num_keys ()Warning ⚠
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 65/83If the queue doesnʼt exist it returns 0.
See queue_push for more details.
Parameters:
key (str) – The key of the queue to get the length.
queue_pop (self: torch._C._distributed_c10d.Store , key: str, block:
bool = True ) → bytes
Pops a value from the specified queue or waits until timeout if the queue is empty.
See queue_push for more details.
If block is False, a dist.QueueEmptyError will be raised if the queue is empty.
Parameters:
key (str) – The key of the queue to pop from.
block (bool) – Whether to block waiting for the key or immediately return.
queue_push (self: torch._C._distributed_c10d.Store , arg0: str, arg1:
str ) → None
Pushes a value into the specified queue.
Using the same key for queues and set/get operations may result in unexpected behavior.
wait/check operations are supported for queues.
wait with queues will only wake one waiting worker rather than all.
Parameters:
key (str) – The key of the queue to push to.
value (str) – The value to push into the queue.
set (self: torch._C._distributed_c10d.Store , arg0: str, arg1: str ) →
NoneTo analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 66/83Inserts the key-value pair into the store based on the supplied key and value. If key
already exists in the store, it will overwrite the old value with the new supplied value.
Parameters:
key (str) – The key to be added to the store.
value (str) – The value associated with key to be added to the store.
Example::
set_timeout (self: torch._C._distributed_c10d.Store , arg0:
datetime.timedelta ) → None
Sets the storeʼs default timeout. This timeout is used during initialization and in wait()
and get().
Parameters:
timeout (timedelta) – timeout to be set in the store.
Example::
property  timeout
Gets the timeout of the store.>>> import torch.distributed  as dist
>>> from datetime  import timedelta
>>> store = dist.TCPStore ("127.0.0.1" , 0, 1, True, timedelta (seconds=30
>>> store.set("first_key" , "first_value" )
>>> # Should return "first_value"
>>> store.get("first_key" )
>>> import torch.distributed  as dist
>>> from datetime  import timedelta
>>> # Using TCPStore as an example, other store types can also be used
>>> store = dist.TCPStore ("127.0.0.1" , 0, 1, True, timedelta (seconds=30
>>> store.set_timeout (timedelta (seconds=10))
>>> # This will throw an exception after 10 seconds
>>> store.wait(["bad_key" ])
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 67/83wait (*args, **kwargs )
Overloaded function.
1. wait(self: torch._C._distributed_c10d.Store, arg0: list[str]) -> None
Waits for each key in keys to be added to the store. If not all keys are set before the
timeout (set during store initialization), then wait will throw an exception.
Parameters:
keys (list) – List of keys on which to wait until they are set in the store.
Example::
2. wait(self: torch._C._distributed_c10d.Store, arg0: list[str], arg1: datetime.timedelta) ->
None
Waits for each key in keys to be added to the store, and throws an exception if the keys
have not been set by the supplied timeout.
Parameters:
keys (list) – List of keys on which to wait until they are set in the store.
timeout (timedelta) – Time to wait for the keys to be added before throwing an
exception.
Example::>>> import torch.distributed  as dist
>>> from datetime  import timedelta
>>> # Using TCPStore as an example, other store types can also be used
>>> store = dist.TCPStore ("127.0.0.1" , 0, 1, True, timedelta (seconds=30
>>> # This will throw an exception after 30 seconds
>>> store.wait(["bad_key" ])
>>> import torch.distributed  as dist
>>> from datetime  import timedelta
>>> # Using TCPStore as an example, other store types can also be used
>>> store = dist.TCPStore ("127.0.0.1" , 0, 1, True, timedelta (seconds=30
>>> # This will throw an exception after 10 seconds
>>> store.wait(["bad_key" ], timedelta (seconds=10))To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 68/83class torch.distributed. TCPStore
A TCP-based distributed key-value store implementation. The server store holds the data, whi
the client stores can connect to the server store over TCP and perform actions such as set()
to insert a key-value pair, get() to retrieve a key-value pair, etc. There should always be one
server store initialized because the client store(s) will wait for the server to establish a
connection.
Parameters:
host_name (str) – The hostname or IP Address the server store should run on.
port (int) – The port on which the server store should listen for incoming requests.
world_size (int, optional) – The total number of store users (number of clients + 1 for
the server). Default is None (None indicates a non-fixed number of store users).
is_master (bool, optional) – True when initializing the server store and False for client
stores. Default is False.
timeout (timedelta, optional) – Timeout used by the store during initialization and for
methods such as get() and wait(). Default is timedelta(seconds=300)
wait_for_workers (bool, optional) – Whether to wait for all the workers to connect with
the server store. This is only applicable when world_size is a fixed value. Default is True
multi_tenant (bool, optional) – If True, all TCPStore  instances in the current process
with the same host/port will use the same underlying TCPServer. Default is False.
master_listen_fd (int, optional) – If specified, the underlying TCPServer  will listen on
this file descriptor, which must be a socket already bound to port. To bind an
ephemeral port we recommend setting the port to 0 and reading .port. Default is
None (meaning the server creates a new socket and attempts to bind it to port).
use_libuv (bool, optional) – If True, use libuv for TCPServer  backend. Default is True.
Example::
>>> import torch.distributed  as dist
>>> from datetime  import timedelta
>>> # Run on process 1 (server)
>>> server_store  = dist.TCPStore ("127.0.0.1" , 1234, 2, True, timedelta (seco
>>> # Run on process 2 (client)
>>> client_store  = dist.TCPStore ("127.0.0.1" , 1234, 2, False)
>>> # Use any of the store methods from either the client or server after i
>>> server_store .set("first_key" , "first_value" )
>>> client_store .get("first_key" )To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 69/83__init__ (self: torch._C._distributed_c10d.TCPStore , host_name : str,
port: int, world_size : Optional [int] = None, is_master : bool = False,
timeout: datetime.timedelta  = datetime.timedelta(seconds=300) ,
wait_for_workers : bool = True, multi_tenant : bool = False,
master_listen_fd : Optional [int] = None, use_libuv : bool = True ) →
None
Creates a new TCPStore.
property  host
Gets the hostname on which the store listens for requests.
property  libuvBackend
Returns True if itʼs using the libuv backend.
property  port
Gets the port number on which the store listens for requests.
class torch.distributed. HashStore
A thread-safe store implementation based on an underlying hashmap. This store can be used
within the same process (for example, by other threads), but cannot be used across processes
Example::
__init__ (self: torch._C._distributed_c10d.HashStore ) → None
Creates a new HashStore.>>> import torch.distributed  as dist
>>> store = dist.HashStore ()
>>> # store can be used from other threads
>>> # Use any of the store methods after initialization
>>> store.set("first_key" , "first_value" )
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 70/83class torch.distributed. FileStore
A store implementation that uses a file to store the underlying key-value pairs.
Parameters:
file_name (str) – path of the file in which to store the key-value pairs
world_size (int, optional) – The total number of processes using the store. Default is -
(a negative value indicates a non-fixed number of store users).
Example::
__init__ (self: torch._C._distributed_c10d.FileStore , file_name : str,
world_size : int = -1 ) → None
Creates a new FileStore.
property  path
Gets the path of the file used by FileStore to store key-value pairs.
class torch.distributed. PrefixStore
A wrapper around any of the 3 key-value stores (TCPStore, FileStore, and HashStore) tha
adds a prefix to each key inserted to the store.
Parameters:
prefix (str) – The prefix string that is prepended to each key before being inserted into
the store.
store (torch.distributed.store) – A store object that forms the underlying key-value
store.>>> import torch.distributed  as dist
>>> store1 = dist.FileStore ("/tmp/filestore" , 2)
>>> store2 = dist.FileStore ("/tmp/filestore" , 2)
>>> # Use any of the store methods from either the client or server after i
>>> store1.set("first_key" , "first_value" )
>>> store2.get("first_key" )
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 71/83__init__ (self: torch._C._distributed_c10d.PrefixStore , prefix: str,
store: torch._C._distributed_c10d.Store ) → None
Creates a new PrefixStore.
property  underlying_store
Gets the underlying store object that PrefixStore wraps around.
Profiling Collective Communication
Note that you can use torch.profiler  (recommended, only available after 1.8.1) or
torch.autograd.profiler  to profile collective communication and point-to-point communication
APIs mentioned here. All out-of-the-box backends (gloo, nccl, mpi) are supported and
collective communication usage will be rendered as expected in profiling output/traces. Profiling
your code is the same as any regular torch operator:
Please refer to the profiler documentation for a full overview of profiler features.
Multi-GPU collective functions
The multi-GPU functions (which stand for multiple GPUs per CPU thread) are deprecated.
As of today, PyTorch Distributedʼs preferred programming model is one device per thread,
as exemplified by the APIs in this document. If you are a backend developer and want to
support multiple devices per thread, please contact PyTorch Distributedʼs maintainers.
Object collectivesimport torch
import torch.distributed  as dist
with torch.profiler ():
    tensor = torch.randn(20, 10)
    dist.all_reduce (tensor)
Warning ⚠
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 72/83Object collectives have a number of serious limitations. Read further to determine if they
are safe to use for your use case.
Object collectives are a set of collective-like operations that work on arbitrary Python objects, as
long as they can be pickled. There are various collective patterns implemented (e.g. broadcast,
all_gather, …) but they each roughly follow this pattern:
1. convert the input object into a pickle (raw bytes), then shove it into a byte tensor
2. communicate the size of this byte tensor to peers (first collective operation)
3. allocate appropriately sized tensor to perform the real collective
4. communicate the object data (second collective operation)
5. convert raw data back into Python (unpickle)
Object collectives sometimes have surprising performance or memory characteristics that lead to
long runtimes or OOMs, and thus they should be used with caution. Here are some common issues
Asymmetric pickle/unpickle time - Pickling objects can be slow, depending on the number, type
and size of the objects. When the collective has a fan-in (e.g. gather_object), the receiving rank(s)
must unpickle N times more objects than the sending rank(s) had to pickle, which can cause other
ranks to time out on their next collective.
Inefficient tensor communication - Tensors should be sent via regular collective APIs, not object
collective APIs. It is possible to send Tensors via object collective APIs, but they will be serialized
and deserialized (including a CPU-sync and device-to-host copy in the case of non-CPU tensors),
and in almost every case other than debugging or troubleshooting code, it would be worth the
trouble to refactor the code to use non-object collectives instead.
Unexpected tensor devices - If you still want to send tensors via object collectives, there is
another aspect specific to cuda (and possibly other accelerators) tensors. If you pickle a tensor tha
is currently on cuda:3, and then unpickle it, you will get another tensor on cuda:3regardless of
which process you are on, or which CUDA device is the ‘defaultʼ device for that process. With
regular tensor collective APIs, ‘output tensorsʼ will always be on the same, local device, which is
generally what youʼd expect.
Unpickling a tensor will implicitly activate a CUDA context if it is the first time a GPU is used by the
process, which can waste significant amounts of GPU memory. This issue can be avoided by movinWarning ⚠
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 73/83tensors to CPU before passing them as inputs to an object collective.
Third-party backends
Besides the builtin GLOO/MPI/NCCL backends, PyTorch distributed supports third-party backends
through a run-time register mechanism. For references on how to develop a third-party backend
through C++ Extension, please refer to Tutorials - Custom C++ and CUDA Extensions and
test/cpp_extensions/cpp_c10d_extension.cpp . The capability of third-party backends are
decided by their own implementations.
The new backend derives from c10d::ProcessGroup  and registers the backend name and the
instantiating interface through torch.distributed.Backend.register_backend()  when imported
When manually importing this backend and invoking torch.distributed.init_process_group()
with the corresponding backend name, the torch.distributed  package runs on the new backend
The support of third-party backend is experimental and subject to change.
Launch utility
The torch.distributed  package also provides a launch utility in torch.distributed.launch .
This helper utility can be used to launch multiple processes per node for distributed training.
Module torch.distributed.launch .
torch.distributed.launch  is a module that spawns up multiple distributed training processes on
each of the training nodes.
This module is going to be deprecated in favor of torchrun.
The utility can be used for single-node distributed training, in which one or more processes per
node will be spawned. The utility can be used for either CPU training or GPU training. If the utility isWarning ⚠
Warning ⚠
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 74/83used for GPU training, each distributed process will be operating on a single GPU. This can achieve
well-improved single-node training performance. It can also be used in multi-node distributed
training, by spawning up multiple processes on each node for well-improved multi-node distributed
training performance as well. This will especially be beneficial for systems with multiple Infiniband
interfaces that have direct-GPU support, since all of them can be utilized for aggregated
communication bandwidth.
In both cases of single-node distributed training or multi-node distributed training, this utility will
launch the given number of processes per node (--nproc-per-node). If used for GPU training, thi
number needs to be less or equal to the number of GPUs on the current system (nproc_per_node
and each process will be operating on a single GPU from GPU 0 to GPU (nproc_per_node - 1).
How to use this module:
1. Single-Node multi-process distributed training
2. Multi-Node multi-process distributed training: (e.g. two nodes)
Node 1: (IP: 192.168.1.1, and has a free port: 1234)
Node 2:
3. To look up what optional arguments this module offers:python -m torch.distributed .launch --nproc-per-node=NUM_GPUS_YOU_HAVE
           YOUR_TRAINING_SCRIPT .py (--arg1 --arg2 --arg3 and all other
           arguments  of your training  script)
python -m torch.distributed .launch --nproc-per-node=NUM_GPUS_YOU_HAVE
           --nnodes=2 --node-rank=0 --master-addr="192.168.1.1"
           --master-port=1234 YOUR_TRAINING_SCRIPT .py (--arg1 --arg2 --arg3
           and all other arguments  of your training  script)
python -m torch.distributed .launch --nproc-per-node=NUM_GPUS_YOU_HAVE
           --nnodes=2 --node-rank=1 --master-addr="192.168.1.1"
           --master-port=1234 YOUR_TRAINING_SCRIPT .py (--arg1 --arg2 --arg3
           and all other arguments  of your training  script)
python -m torch.distributed .launch --helpTo analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 75/83Important Notices:
1. This utility and multi-process distributed (single-node or multi-node) GPU training currently only
achieves the best performance using the NCCL distributed backend. Thus NCCL backend is the
recommended backend to use for GPU training.
2. In your training program, you must parse the command-line argument:
--local-rank=LOCAL_PROCESS_RANK , which will be provided by this module. If your training
program uses GPUs, you should ensure that your code only runs on the GPU device of
LOCAL_PROCESS_RANK. This can be done by:
Parsing the local_rank argument
Set your device to local rank using either
or>>> import argparse
>>> parser = argparse .ArgumentParser ()
>>> parser.add_argument ("--local-rank" , "--local_rank" , type=int)
>>> args = parser.parse_args ()
>>> torch.cuda.set_device (args.local_rank )  # before your code runs
>>> with torch.cuda.device(args.local_rank ):
>>>    # your code to run
>>>    ...
Changed in version 2.0.0: The launcher will passes the --local-rank=<rank>  argument to
your script. From PyTorch 2.0.0 onwards, the dashed --local-rank  is preferred over the
previously used underscored --local_rank.
For backward compatibility, it may be necessary for users to handle both cases in their argument
parsing code. This means including both "--local-rank"  and "--local_rank"  in the
argument parser. If only "--local_rank"  is provided, the launcher will trigger an error: “error:
unrecognized arguments: –local-rank=<rank>”. For training code that only supports PyTorch
2.0.0+, including "--local-rank"  should be sufficient.To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 76/833. In your training program, you are supposed to call the following function at the beginning to start
the distributed backend. It is strongly recommended that init_method=env:// . Other init method
(e.g. tcp://) may work, but env:// is the one that is officially supported by this module.
4. In your training program, you can either use regular distributed functions or use
torch.nn.parallel.DistributedDataParallel()  module. If your training program uses GPUs fo
training and you would like to use torch.nn.parallel.DistributedDataParallel()  module, here
is how to configure it.
Please ensure that device_ids  argument is set to be the only GPU device id that your code will be
operating on. This is generally the local rank of the process. In other words, the device_ids  need
to be [args.local_rank], and output_device  needs to be args.local_rank  in order to use th
utility
5. Another way to pass local_rank  to the subprocesses via environment variable LOCAL_RANK.
This behavior is enabled when you launch the script with --use-env=True. You must adjust the
subprocess example above to replace args.local_rank  with os.environ['LOCAL_RANK'] ; the
launcher will not pass --local-rank  when you specify this flag.
local_rank  is NOT globally unique: it is only unique per process on a machine. Thus,
donʼt use it to decide if you should, e.g., write to a networked filesystem. See
pytorch/pytorch#12042 for an example of how things can go wrong if you donʼt do this
correctly.
Spawn utility>>> torch.distributed .init_process_group (backend='YOUR BACKEND' ,
>>>                                      init_method ='env://' )
>>> model = torch.nn.parallel .DistributedDataParallel (model,
>>>                                                   device_ids =[args.local_rank ],
>>>                                                   output_device =args.local_rank
Warning ⚠
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 77/83The Multiprocessing package - torch.multiprocessing package also provides a spawn function in
torch.multiprocessing.spawn() . This helper function can be used to spawn multiple processes
It works by passing in the function that you want to run and spawns N processes to run it. This can
be used for multiprocess distributed training as well.
For references on how to use it, please refer to PyTorch example - ImageNet implementation
Note that this function requires Python 3.4 or higher.
Debugging torch.distributed  applications
Debugging distributed applications can be challenging due to hard to understand hangs, crashes, o
inconsistent behavior across ranks. torch.distributed  provides a suite of tools to help debug
training applications in a self-serve fashion:
Python Breakpoint
It is extremely convenient to use pythonʼs debugger in a distributed environment, but because it
does not work out of the box many people do not use it at all. PyTorch offers a customized wrapper
around pdb that streamlines the process.
torch.distributed.breakpoint  makes this process easy. Internally, it customizes pdbʼs
breakpoint behavior in two ways but otherwise behaves as normal pdb.
1. Attaches the debugger only on one rank (specified by the user).
2. Ensures all other ranks stop, by using a torch.distributed.barrier()  that will release once
the debugged rank issues a continue
3. Reroutes stdin from the child process such that it connects to your terminal.
To use it, simply issue torch.distributed.breakpoint(rank)  on all ranks, using the same value
for rank in each case.
Monitored Barrier
As of v1.10, torch.distributed.monitored_barrier()  exists as an alternative to
torch.distributed.barrier()  which fails with helpful information about which rank may be faultTo analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 78/83when crashing, i.e. not all ranks calling into torch.distributed.monitored_barrier()  within the
provided timeout. torch.distributed.monitored_barrier()  implements a host-side barrier usin
send/recv communication primitives in a process similar to acknowledgements, allowing rank 0 t
report which rank(s) failed to acknowledge the barrier in time. As an example, consider the followin
function where rank 1 fails to call into torch.distributed.monitored_barrier()  (in practice this
could be due to an application bug or hang in a previous collective):
The following error message is produced on rank 0, allowing the user to determine which rank(s)
may be faulty and investigate further:
TORCH_DISTRIBUTED_DEBUG
With TORCH_CPP_LOG_LEVEL=INFO , the environment variable TORCH_DISTRIBUTED_DEBUG  can be
used to trigger additional useful logging and collective synchronization checks to ensure all ranks
are synchronized appropriately. TORCH_DISTRIBUTED_DEBUG  can be set to either OFF (default),
INFO, or DETAIL depending on the debugging level required. Please note that the most verboseimport os
from datetime  import timedelta
import torch
import torch.distributed  as dist
import torch.multiprocessing  as mp
def worker(rank):
    dist.init_process_group ("nccl", rank=rank, world_size =2)
    # monitored barrier requires gloo process group to perform host-side sync.
    group_gloo  = dist.new_group (backend="gloo")
    if rank not in [1]:
        dist.monitored_barrier (group=group_gloo , timeout=timedelta (seconds=2))
if __name__  == "__main__" :
    os.environ["MASTER_ADDR" ] = "localhost"
    os.environ["MASTER_PORT" ] = "29501"
    mp.spawn(worker, nprocs=2, args=())
RuntimeError : Rank 1 failed to pass monitoredBarrier  in 2000 ms
 Original  exception :
[gloo/transport /tcp/pair.cc:598] Connection  closed by peer [2401:db00:eef0:1100:356
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 79/83option, DETAIL may impact the application performance and thus should only be used when
debugging issues.
Setting TORCH_DISTRIBUTED_DEBUG=INFO  will result in additional debug logging when models
trained with torch.nn.parallel.DistributedDataParallel()  are initialized, and
TORCH_DISTRIBUTED_DEBUG=DETAIL  will additionally log runtime performance statistics a select
number of iterations. These runtime statistics include data such as forward time, backward time,
gradient communication time, etc. As an example, given the following application:
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 80/83The following logs are rendered at initialization time:import os
import torch
import torch.distributed  as dist
import torch.multiprocessing  as mp
class TwoLinLayerNet (torch.nn.Module):
    def __init__ (self):
        super().__init__ ()
        self.a = torch.nn.Linear(10, 10, bias=False)
        self.b = torch.nn.Linear(10, 1, bias=False)
    def forward(self, x):
        a = self.a(x)
        b = self.b(x)
        return (a, b)
def worker(rank):
    dist.init_process_group ("nccl", rank=rank, world_size =2)
    torch.cuda.set_device (rank)
    print("init model" )
    model = TwoLinLayerNet ().cuda()
    print("init ddp" )
    ddp_model  = torch.nn.parallel .DistributedDataParallel (model, device_ids =[rank])
    inp = torch.randn(10, 10).cuda()
    print("train")
    for _ in range(20):
        output = ddp_model (inp)
        loss = output[0] + output[1]
        loss.sum().backward ()
if __name__  == "__main__" :
    os.environ["MASTER_ADDR" ] = "localhost"
    os.environ["MASTER_PORT" ] = "29501"
    os.environ["TORCH_CPP_LOG_LEVEL" ]="INFO"
    os.environ[
        "TORCH_DISTRIBUTED_DEBUG"
    ] = "DETAIL"   # set to DETAIL for runtime logging.
    mp.spawn(worker, nprocs=2, args=())
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 81/83Previous
Dynamo Deep-DiveNext
torch.distributed.tensorRate this Page★★★★★
© Copyright PyTorch Contributors.
Built with the PyData Sphinx Theme 0.15.4.I0607 16:10:35.739390  515217 logger.cpp:173] [Rank 0]: DDP Initialized  with:
broadcast_buffers : 1
bucket_cap_bytes : 26214400
find_unused_parameters : 0
gradient_as_bucket_view : 0
is_multi_device_module : 0
iteration : 0
num_parameter_tensors : 2
output_device : 0
rank: 0
total_parameter_size_bytes : 440
world_size : 2
backend_name : nccl
bucket_sizes : 440
cuda_visible_devices : N/A
device_ids : 0
dtypes: float
master_addr : localhost
master_port : 29501
module_name : TwoLinLayerNet
nccl_async_error_handling : N/A
nccl_blocking_wait : N/A
nccl_debug : WARN
nccl_ib_timeout : N/A
nccl_nthreads : N/A
nccl_socket_ifname : N/A
torch_distributed_debug : INFOSend Feedback
Docs
Access comprehensive
developer documentation
for PyTorchTutorials
Get in-depth tutorials for
beginners and advanced
developersResources
Find development
resources and get your
questions answered
View Docs View Tutorials View Resources
Stay in touch for updates, event info, and the latest news
First Name* Last Name* Email*To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 82/83Select Country* SUBMIT
By submitting this form, I consent to receive marketing emails from the LF and its projects
regarding their events, training, research, developments, and related announcements. I understand
that I can unsubscribe at any time using the links in the footers of the emails I receive. Privacy
Policy.
© PyTorch. Copyright © The Linux Foundation®. All rights reserved. The Linux Foundation has
registered trademarks and uses trademarks. For more information, including terms of use, privacy
policy, and trademark usage, please see our Policies page. Trademark Usage. Privacy Policy.
To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or
navigating, you agree to allow our usage of cookies. As the current maintainers of this site,
Facebookʼs Cookies Policy applies. Learn more, including about available controls: Cookies
Policy.10/10/25, 3:03 PM Distributed communication package - torch.distributed — PyTorch 2.8 documentation
https://docs.pytorch.org/docs/stable/distributed.html 83/83